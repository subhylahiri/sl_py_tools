/* Basic GUFuncs without BLAS
*/
/*
Adapted from https://github.com/numpy/numpy/numpy/linalg/umath_linalg.c.src
Copyright/licence info for that file:
* Copyright (c) 2005-2017, NumPy Developers.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
*   - Redistributions of source code must retain the above
*     copyright notice, this list of conditions and the
*     following disclaimer.
*   - Redistributions in binary form must reproduce the above copyright
*     notice, this list of conditions and the following disclaimer
*     in the documentation and/or other materials provided with the
*     distribution.
*   - Neither the name of the author nor the names of its
*     contributors may be used to endorse or promote products derived
*     from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
* A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*              Table of Contents
50.  Includes
69.  Docstrings
134. Structs used for array iteration
164. UFUNC LOOPS
    324. matmul
    382. norm
417. Ufunc definition
439. Module initialization stuff
*/

/*
*****************************************************************************
**                            INCLUDES                                     **
*****************************************************************************
*/
#define NPY_NO_DEPRECATED_API NPY_API_VERSION

#include "Python.h"
#include "numpy/ndarraytypes.h"
#include "numpy/arrayobject.h"
#include "numpy/ufuncobject.h"
#include "numpy/npy_math.h"
#include "numpy/npy_3kcompat.h"
// #include "npy_config.h"
#define NO_FORTRAN
#include "gufunc_common.h"

static const char* gufuncs_cloop_version_string = "0.1.1";

/*
*****************************************************************************
**                   Doc string for Python functions                       **
*****************************************************************************
*/

PyDoc_STRVAR(matmul__doc__,
//"matmul(X: ndarray, Y: ndarray) -> (Z: ndarray)\n\n"
"Matrix-matrix product.\n\n"
"Parameters\n-----------\n"
"X: ndarray (...,M,N)\n"
"    Matrix multiplying from left.\n"
"Y: ndarray (...,N,P)\n"
"    Matrix multiplying from right.\n\n"
"Returns\n-------\n"
"Z: ndarray (...,M,P)\n"
"    Result of matrix multiplication.");

PyDoc_STRVAR(norm__doc__,
//"matmul(X: ndarray, Y: ndarray) -> (Z: ndarray)\n\n"
"Euclidean norm of a vector.\n\n"
"Parameters\n-----------\n"
"X: ndarray (...,N)\n"
"    Vector, or array of vectors.\n\n"
"Returns\n-------\n"
"Z: float\n"
"    Euclidean norm of X.");

/*
*****************************************************************************
**                             UFUNC LOOPS                                 **
*****************************************************************************
*/

/* **********************************
            MATMUL
********************************** */
/**begin repeat
    #TYPE=LONG,FLOAT,DOUBLE#
    #typ=npy_long,npy_float,npy_double#
*/
static @typ@
@TYPE@_add_product_scalar(const @typ@ *x_in, const @typ@ *y_in, @typ@ *z_out)
{
    *z_out += *x_in * *y_in;
}
/**end repeat**/

/**begin repeat
    #TYPE=CFLOAT,CDOUBLE#
    #typ=COMPLEX_t,DOUBLECOMPLEX_t#
*/
static @typ@
@TYPE@_add_product_scalar(const @typ@ *x_in, const @typ@ *y_in, @typ@ *z_out)
{
    z_out->array[0] += x_in->array[0] * y_in->array[0];
    z_out->array[0] -= x_in->array[1] * y_in->array[1];
    z_out->array[1] += x_in->array[0] * y_in->array[1];
    z_out->array[1] += x_in->array[1] * y_in->array[0];
}
/**end repeat**/

/**begin repeat
    #TYPE=LONG,FLOAT,DOUBLE,CFLOAT,CDOUBLE#
    #typ=npy_long,npy_float,npy_double,COMPLEX_t,DOUBLECOMPLEX_t#
    #zero=0,s_zero,d_zero,c_zero,z_zero#
*/

// matmul_signature = "(m,n),(n,p)->(m,p)";

static void
@TYPE@_matmul(char **args, npy_intp *dimensions, npy_intp *steps,
              void *NPY_UNUSED(func))
{
INIT_OUTER_LOOP_3

    npy_intp len_m = *dimensions++;  // dimensions of left
    npy_intp len_n = *dimensions++;  // dimensions of inner
    npy_intp len_p = *dimensions++;  // dimensions of right
    npy_intp stride_x_m = *steps++;  // 1st arg
    npy_intp stride_x_n = *steps++;
    npy_intp stride_y_n = *steps++;  // 2nd arg
    npy_intp stride_y_p = *steps++;
    npy_intp stride_z_m = *steps++;  // output
    npy_intp stride_z_p = *steps++;
    npy_intp m, n, p;
    npy_intp iback_x_n = len_n * stride_x_n;  // step back at end of loop
    npy_intp iback_y_n = len_n * stride_y_n;
    npy_intp iback_y_p = len_p * stride_y_p;  // step back at end of loop
    npy_intp iback_z_p = len_p * stride_z_p;

    BEGIN_OUTER_LOOP

        const char *ip_x= args[0];  //  1st arg
        const char *ip_y= args[1];  //  2nd arg
        char *op_z = args[2];       //  output

        for (m = 0; m < len_m; m++) {
            for (p = 0; p < len_p; p++) {
                *(@typ@ *)op_z = @zero@;

                for (n = 0; n < len_n; n++) {
                    @TYPE@_add_product_scalar((@typ@ *)ip_x, (@typ@ *)ip_y, (@typ@ *)op_z);

                    ip_x += stride_x_n;
                    ip_y += stride_y_n;
                }
                ip_x -= iback_x_n;
                ip_y -= iback_y_n;

                ip_y += stride_y_p;
                op_z += stride_z_p;
            }
            ip_y -= iback_y_p;
            op_z -= iback_z_p;

            ip_x += stride_x_m;
            op_z += stride_z_m;
        }

    END_OUTER_LOOP_3
}

/**end repeat**/

/* **********************************
            NORM
********************************** */

/**begin repeat
    #TYPE=FLOAT,DOUBLE#
    #typ=npy_float,npy_double#
    #sqrt=npy_sqrtf,npy_sqrt#
    #zero=s_zero,d_zero#
*/

// norm_signature = "(n)->()";

static void
@TYPE@_norm(char **args, npy_intp *dimensions, npy_intp *steps,
              void *NPY_UNUSED(func))
{
INIT_OUTER_LOOP_2

    npy_intp len_n = *dimensions++;  // dimensions of inner
    npy_intp stride_n = *steps++;
    npy_intp n;
    @typ@ normsq;

    BEGIN_OUTER_LOOP

        const char *ip_x= args[0];  //  1st arg
        char *op_r = args[1];       //  output
        normsq = @zero@;

        for (n = 0; n < len_n; n++) {
            normsq += *(@typ@ *)ip_x * *(@typ@ *)ip_x;

            ip_x += stride_n;
        }
        *(@typ@ *)op_r = @sqrt@(normsq);

    END_OUTER_LOOP_2
}

/**end repeat**/

/**begin repeat
    #TYPE=CFLOAT,CDOUBLE#
    #typ=COMPLEX_t,DOUBLECOMPLEX_t#
    #rtyp=npy_float,npy_double#
    #sqrt=npy_sqrtf,npy_sqrt#
    #zero=s_zero,d_zero#
*/

// norm_signature = "(n)->()";

static void
@TYPE@_norm(char **args, npy_intp *dimensions, npy_intp *steps,
              void *NPY_UNUSED(func))
{
INIT_OUTER_LOOP_2

    npy_intp len_n = *dimensions++;  // dimensions of inner
    npy_intp stride_n = *steps++;
    npy_intp n;
    @rtyp@ normsq;
    @typ@ *cmpt;

    BEGIN_OUTER_LOOP

        const char *ip_x= args[0];  //  1st arg
        char *op_r = args[1];       //  output
        normsq = @zero@;

        for (n = 0; n < len_n; n++) {
            cmpt = (@typ@ *)ip_x;
            normsq += cmpt->array[0] * cmpt->array[0] + cmpt->array[1] * cmpt->array[1];

            ip_x += stride_n;
        }
        *(@rtyp@ *)op_r = @sqrt@(normsq);

    END_OUTER_LOOP_2
}

/**end repeat**/

/*
*****************************************************************************
**                             UFUNC DEFINITION                            **
*****************************************************************************
*/

static char ufn_types_norm[] = { NPY_FLOAT, NPY_FLOAT,
                                NPY_DOUBLE, NPY_DOUBLE,
                                NPY_CFLOAT, NPY_FLOAT,
                                NPY_CDOUBLE, NPY_DOUBLE };

GUFUNC_FUNC_ARRAY_REAL_COMPLEX_INT(matmul);
GUFUNC_FUNC_ARRAY_REAL_COMPLEX(norm);

GUFUNC_DESCRIPTOR_t gufunc_descriptors[] = {
    { "matmul", "(m,n),(n,p)->(m,p)", matmul__doc__, 5, 2, 1,
      FUNC_ARRAY_NAME(matmul), ufn_types_5_3 },
    { "norm", "(n)->()", norm__doc__, 4, 1, 1,
      FUNC_ARRAY_NAME(norm), ufn_types_norm }
};

/*
*****************************************************************************
**               Module initialization stuff                               **
*****************************************************************************
*/

static PyMethodDef GUfuncs_Cloop_Methods[] = {
    {NULL, NULL, 0, NULL}        /* Sentinel */
};

static struct PyModuleDef moduledef = {
        PyModuleDef_HEAD_INIT,
        "_gufuncs_cloop",
        NULL,
        -1,
        GUfuncs_Cloop_Methods,
        NULL,
        NULL,
        NULL,
        NULL
};

PyObject *PyInit__gufuncs_cloop(void)
{
    PyObject *m;
    PyObject *d;
    PyObject *version;

    init_constants();
    m = PyModule_Create(&moduledef);
    if (m == NULL) {
        return NULL;
    }

    import_array();
    import_ufunc();

    d = PyModule_GetDict(m);

    version = PyString_FromString(gufuncs_cloop_version_string);
    PyDict_SetItemString(d, "__version__", version);
    Py_DECREF(version);

    /* Load the ufunc operators into the module's namespace */
    int failure = addUfuncs(d, gufunc_descriptors, 4);

    if (PyErr_Occurred() || failure) {
        PyErr_SetString(PyExc_RuntimeError,
                        "cannot load _gufuncs_cloop module.");
        return NULL;
    }

    return m;
}
