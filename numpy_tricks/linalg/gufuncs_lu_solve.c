#line 1 "gufuncs_lu_solve.c.src"

/*
 *****************************************************************************
 **       This file was autogenerated from a template  DO NOT EDIT!!!!      **
 **       Changes should be made to the original source (.src) file         **
 *****************************************************************************
 */

#line 1
/* -*- Mode: C -*- */
/* GUFuncs with Lapack from the LU / solve family
*/
/*
Adapted from https://github.com/numpy/numpy/numpy/linalg/umath_linalg.c.src
Copyright/licence info for that file:
* Copyright (c) 2005-2017, NumPy Developers.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
*   - Redistributions of source code must retain the above
*     copyright notice, this list of conditions and the
*     following disclaimer.
*   - Redistributions in binary form must reproduce the above copyright
*     notice, this list of conditions and the following disclaimer
*     in the documentation and/or other materials provided with the
*     distribution.
*   - Neither the name of the author nor the names of its
*     contributors may be used to endorse or promote products derived
*     from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
* A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
*****************************************************************************
**                            Includes                                     **
*****************************************************************************
*/
#define NPY_NO_DEPRECATED_API NPY_API_VERSION

#include "gufunc_common_f.h"
#include "rearrange_data.h"

static const char* gufuncs_lu_solve_version_string = "0.1.0";
/*
*****************************************************************************
**                   Doc string for Python functions                       **
*****************************************************************************
*/

/*******************
*        LU        *
********************/

PyDoc_STRVAR(lu__doc__,
//"solve(A: ndarray, B: ndarray) -> (C: ndarray)\n\n"
"LU decomposition.\n\n"
"Write matrix ``A`` as ``A = PLU``, where  ``P`` is a permutation matrix, \n"
"``L`` is lower triangular with ones on the diagonal and \n"
"``U`` is upper triangular.\n\n"
"Parameters\n-----------\n"
"A: ndarray (...,M,N)\n"
"    Matrix to be fcatored.\n\n"
"Returns\n-------\n"
"L: ndarray (...,M,K)\n"
"    Lower diagonal matrix with unit diagonals. ``K=min(M,N)``.\n"
"U: ndarray (...,K,N)\n"
"    Upper triangular matrix.\n"
"IP: ndarray (...,K)\n"
"   Vector of pivot indices, where swaps ``A[...,i,:] <--> A[...,IP[i],:]`` \n"
"   are performed in order ``i=1,...,K``."
);

PyDoc_STRVAR(lu_raw__doc__,
//"solve(A: ndarray, B: ndarray) -> (C: ndarray)\n\n"
"LU decomposition.\n\n"
"Write matrix ``A`` as ``A = PLU``, where  ``P`` is a permutation matrix, \n"
"``L`` is lower triangular with ones on the diagonal and \n"
"``U`` is upper triangular.\n\n"
"Parameters\n-----------\n"
"A: ndarray (...,M,N)\n"
"    Matrix to be fcatored.\n\n"
"Returns\n-------\n"
"AF: ndarray (...,M,N)\n"
"   LU factors of ``A``, with the nonzero elements of ``U`` above and on \n"
"   the diagonal, nonzero elements of ``L`` below the diagonal. \n"
"   The diagonal elements of ``L``, which are all 1, are not stored."
"IP: ndarray (...,K)\n"
"   Vector of pivot indices, where swaps ``A[...,i,:] <--> A[...,IP[i],:]`` \n"
"   are performed in order ``i=1,...,K``, ``K=min(M,N)``."
);

/*******************
*       Solve      *
********************/

PyDoc_STRVAR(solve__doc__,
//"solve(A: ndarray, B: ndarray) -> (C: ndarray)\n\n"
"Solve linear system.\n\n"
"Solve the equation ``AX = B`` for ``X``.\n\n"
"Parameters\n-----------\n"
"A: ndarray (...,N,N)\n"
"    Matrix of coefficients.\n"
"B: ndarray (...,N,NRHS)\n"
"    Matrix of result vectors.\n\n"
"Returns\n-------\n"
"X: ndarray (...,N,NRHS)\n"
"    Matrix of solution vectors.");

PyDoc_STRVAR(rsolve__doc__,
//"solve(A: ndarray, B: ndarray) -> (C: ndarray)\n\n"
"Solve reversed linear system.\n\n"
"Solve the equation `A = XB` for `X`.\n\n"
"Parameters\n-----------\n"
"A: ndarray (...,NRHS,N)\n"
"    Matrix of result vectors.\n"
"B: ndarray (...,N,N)\n"
"    Matrix of coefficients.\n\n"
"Returns\n-------\n"
"X: ndarray (...,NRHS,N)\n"
"    Matrix of solution vectors.");

/********************
*    Solve + LU     *
*********************/

PyDoc_STRVAR(solve_lu__doc__,
//"solve_lu(A: ndarray, B: ndarray) -> (C: ndarray, AF: ndarray, IPIV: ndarray)\n\n"
"Solve linear system.\n\n"
"Solve  equation ``AX = B`` for ``X``. \n"
"This version also returns the LU factors of `A` for future use.\n"
"It is intended for use in binary operators.\n\n"
"Parameters\n-----------\n"
"A: ndarray (...,N,N)\n"
"    Matrix of coefficients.\n"
"B: ndarray (...,N,NRHS)\n"
"    Matrix of result vectors.\n\n"
"Returns\n-------\n"
"X: ndarray (...,N,NRHS)\n"
"    Matrix of solution vectors.\n"
"AF: ndarray (...,N,N)\n"
"    LU factors of ``A``.\n"
"IP: ndarray[int] (...,N)\n"
"    Pivot indices from LU factoring.");

PyDoc_STRVAR(rsolve_lu__doc__,
//"rsolve_lu(A: ndarray, B: ndarray) -> (C: ndarray, BF: ndarray, IPIV: ndarray)\n\n"
"Solve reversed linear system.\n\n"
"Solve the equation ``A = XB`` for ``X``.\n\n"
"This version also returns the LU factors of `B` for future use.\n"
"It is intended for use in binary operators.\n\n"
"Parameters\n-----------\n"
"A: ndarray (...,NRHS,N)\n"
"    Matrix of result vectors.\n"
"B: ndarray (...,N,N)\n"
"    Matrix of coefficients.\n\n"
"Returns\n-------\n"
"X: ndarray (...,NRHS,N)\n"
"    Matrix of solution vectors.\n"
"BF: ndarray (...,N,N)\n"
"    LU factors of ``B``.\n"
"IP: ndarray[int] (...,N)\n"
"    Pivot indices from LU factoring.");

/********************
*   Solve from LU   *
*********************/

PyDoc_STRVAR(lu_solve__doc__,
//"lu_solve(A: ndarray, B: ndarray) -> (C: ndarray, AF: ndarray, IPIV: ndarray)\n\n"
"Solve linear system.\n\n"
"Solve  equation ``AX = B`` for ``X``. \n"
"This version uses the LU factors of ``A`` from previous use of ``(r)solve_f``.\n"
"It is intended for use in binary operators.\n\n"
"Parameters\n-----------\n"
"AF: ndarray (...,N,N)\n"
"    LU factors of ``A``.\n"
"IP: ndarray[int] (...,N)\n"
"    Pivot indices from LU factoring.\n"
"B: ndarray (...,N,NRHS)\n"
"    Matrix of result vectors.\n\n"
"Returns\n-------\n"
"X: ndarray (...,N,NRHS)\n"
"    Matrix of solution vectors.");

PyDoc_STRVAR(rlu_solve__doc__,
//"rlu_rsolve(A: ndarray, B: ndarray) -> (C: ndarray, BF: ndarray, IPIV: ndarray)\n\n"
"Solve reversed linear system.\n\n"
"Solve the equation ``A = XB`` for ``X``.\n\n"
"This version uses the LU factors of ``B`` from previous use of ``(r)solve_f``.\n"
"It is intended for use in binary operators.\n\n"
"Parameters\n-----------\n"
"A: ndarray (...,NRHS,N)\n"
"    Matrix of result vectors.\n"
"BF: ndarray (...,N,N)\n"
"    LU factors of ``B``.\n"
"IP: ndarray[int] (...,N)\n"
"    Pivot indices from LU factoring.\n\n"
"Returns\n-------\n"
"X: ndarray (...,NRHS,N)\n"
"    Matrix of solution vectors.");

/*
*****************************************************************************
**                   BLAS/Lapack calling macros                            **
*****************************************************************************
*/

#line 218

/* solve a x = b for x */
extern void
FNAME(sgesv)(int *n, int *nrhs,
            float *a, int *lda, int * ipiv,
            float *b, int *ldb, int *info);
/* LU factors of a */
extern void
FNAME(sgetrf)(int *m, int *n, float *a, int *lda, int * ipiv, int *info);

/* solve a x = b for x using LU factors of a */
extern void
FNAME(sgetrs)(char *trans, int *n, int *nrhs,
            float *a, int *lda, int * ipiv,
            float *b, int *ldb, int *info);


#line 218

/* solve a x = b for x */
extern void
FNAME(dgesv)(int *n, int *nrhs,
            double *a, int *lda, int * ipiv,
            double *b, int *ldb, int *info);
/* LU factors of a */
extern void
FNAME(dgetrf)(int *m, int *n, double *a, int *lda, int * ipiv, int *info);

/* solve a x = b for x using LU factors of a */
extern void
FNAME(dgetrs)(char *trans, int *n, int *nrhs,
            double *a, int *lda, int * ipiv,
            double *b, int *ldb, int *info);


#line 218

/* solve a x = b for x */
extern void
FNAME(cgesv)(int *n, int *nrhs,
            f2c_complex *a, int *lda, int * ipiv,
            f2c_complex *b, int *ldb, int *info);
/* LU factors of a */
extern void
FNAME(cgetrf)(int *m, int *n, f2c_complex *a, int *lda, int * ipiv, int *info);

/* solve a x = b for x using LU factors of a */
extern void
FNAME(cgetrs)(char *trans, int *n, int *nrhs,
            f2c_complex *a, int *lda, int * ipiv,
            f2c_complex *b, int *ldb, int *info);


#line 218

/* solve a x = b for x */
extern void
FNAME(zgesv)(int *n, int *nrhs,
            f2c_doublecomplex *a, int *lda, int * ipiv,
            f2c_doublecomplex *b, int *ldb, int *info);
/* LU factors of a */
extern void
FNAME(zgetrf)(int *m, int *n, f2c_doublecomplex *a, int *lda, int * ipiv, int *info);

/* solve a x = b for x using LU factors of a */
extern void
FNAME(zgetrs)(char *trans, int *n, int *nrhs,
            f2c_doublecomplex *a, int *lda, int * ipiv,
            f2c_doublecomplex *b, int *ldb, int *info);



/*
******************************************************************************
**                                 LU                                       **
******************************************************************************
*/
typedef struct gesv_params_struct
{
    void *A; /* A is (M,N) of base type */
    void *B; /* B is (N,NRHS) of base type */
    fortran_int *IPIV; /* IPIV is (N,) of int type */

    fortran_int M;
    fortran_int N;
    fortran_int NRHS;
    fortran_int LDA;
    fortran_int LDB;
    fortran_int INFO;
    char TRANS;
} GESV_PARAMS_t;

#line 263

// lu_signature = "(m,n)->(m,k),(k,n),(k)"
// lu_raw_signature = "(m,n)->(m,n),(k)"
/**************************************************
* Calling BLAS/Lapack function _getrf *
***************************************************/

static NPY_INLINE void
call_sgetrf(GESV_PARAMS_t *params)
{
    // A is modified by ?GETRF to carry LU info
    LAPACK(sgetrf)(&params->M, &params->N, params->A, &params->LDA,
                    params->IPIV, &params->INFO);
}

/***************************************************************************
* Initialize the parameters to use in the lapack functions _gesv           *
* Handles buffer allocation
****************************************************************************/
static NPY_INLINE int
init_sgetrf(GESV_PARAMS_t *params, npy_intp M_in, npy_intp N_in)
{
    npy_uint8 *mem_buff = NULL;
    npy_uint8 *a, *b;
    fortran_int M, N, K, lda;
    size_t safe_M, safe_N, safe_K;

    M = (fortran_int)M_in;
    N = (fortran_int)N_in;
    K = fortran_int_min(M, N);
    lda = fortran_int_max(M, 1);
    safe_N = M_in;
    safe_N = N_in;
    safe_K = K;

    mem_buff = malloc(safe_M * safe_N * sizeof(fortran_real)
                    + safe_K * sizeof(fortran_int));
    if (!mem_buff) {
        goto error;
    }
    a = mem_buff;
    b = a + safe_M * safe_N * sizeof(fortran_real);

    params->A = a;
    params->B = NULL;
    params->IPIV = (fortran_int*)b;
    params->M = M;
    params->N = N;
    params->NRHS = N;
    params->LDA = lda;
    params->LDB = 1;
    params->INFO = 0;
    params->TRANS = 'N';

    return 1;

  error:
    free(mem_buff);
    memset(params, 0, sizeof(*params));
    // PyErr_NoMemory();

    return 0;
}

/************************
* Deallocate buffer     *
*************************/

static NPY_INLINE void
release_sgetrf(GESV_PARAMS_t *params)
{
    /* 1st memory block base is in A */
    free(params->A);
    memset(params, 0, sizeof(*params));
}

/************************
* Inner GUfunc loop     *
*************************/

// lu_signature = "(m,n)->(m,k),(k,n),(k)"

static void
FLOAT_lu(char **args, npy_intp *dimensions, npy_intp *steps,
            void *NPY_UNUSED(func))
{
    INIT_OUTER_LOOP_4
    npy_intp len_m = *dimensions++;  // rows
    npy_intp len_n = *dimensions++;  // columns
    npy_intp stride_a_r = *steps++;  // rows
    npy_intp stride_a_c = *steps++;
    npy_intp stride_l_r = *steps++;  // rows
    npy_intp stride_l_c = *steps++;
    npy_intp stride_u_r = *steps++;  // rows
    npy_intp stride_u_c = *steps++;
    npy_intp stride_ip = *steps++;  // elements
    int error_occurred = get_fp_invalid_and_clear();
    GESV_PARAMS_t params;
    LINEARIZE_DATA_t a_in, l_out, u_out, ipiv_out;
    npy_intp len_k = npy_int_min(len_m, len_n);

    if(init_sgetrf(&params, len_m, len_n)) {
        init_linearize_data(&a_in, len_n, len_m, stride_a_c, stride_a_r);
        init_linearize_data(&l_out, len_k, len_m, stride_l_c, stride_l_r);
        init_linearize_data_ex(&u_out, len_n, len_k, stride_u_c, stride_u_r, len_m);
        init_linearize_vdata(&ipiv_out, len_k, stride_ip);

        BEGIN_OUTER_LOOP_4
            int not_ok;
            linearize_FLOAT_matrix(params.A, args[0], &a_in);
            call_sgetrf(&params);
            not_ok = params.INFO;
            if (not_ok) {
                error_occurred = 1;
                nan_FLOAT_matrix(args[1], &l_out);
                nan_FLOAT_matrix(args[2], &u_out);
            } else {
                zero_FLOAT_matrix(args[1], &l_out);
                eye_FLOAT_matrix(args[1], &l_out);
                delinearize_FLOAT_tril(args[1], params.A, &l_out);
                zero_FLOAT_matrix(args[2], &u_out);
                delinearize_FLOAT_triu(args[2], params.A, &u_out);
                delinearize_INT_vec(args[3], params.IPIV, &ipiv_out);
            }
        END_OUTER_LOOP_4
        release_sgetrf(&params);
    }
    set_fp_invalid_or_clear(error_occurred);
}

/************************
*         LU RAW        *
*************************/

// lu_raw_signature = "(m,n)->(m,n),(k)"

static void
FLOAT_lu_raw(char **args, npy_intp *dimensions, npy_intp *steps,
            void *NPY_UNUSED(func))
{
    INIT_OUTER_LOOP_3
    npy_intp len_m = *dimensions++;  // rows
    npy_intp len_n = *dimensions++;  // columns
    npy_intp stride_a_r = *steps++;  // rows
    npy_intp stride_a_c = *steps++;
    npy_intp stride_f_r = *steps++;  // rows
    npy_intp stride_f_c = *steps++;
    npy_intp stride_ip = *steps++;  // elements
    int error_occurred = get_fp_invalid_and_clear();
    GESV_PARAMS_t params;
    LINEARIZE_DATA_t a_in, f_out, ipiv_out;
    npy_intp len_k = npy_int_min(len_m, len_n);

    if(init_sgetrf(&params, len_m, len_n)) {
        init_linearize_data(&a_in, len_n, len_m, stride_a_c, stride_a_r);
        init_linearize_data(&f_out, len_n, len_m, stride_f_c, stride_f_r);
        init_linearize_vdata(&ipiv_out, len_k, stride_ip);

        BEGIN_OUTER_LOOP_3
            int not_ok;
            linearize_FLOAT_matrix(params.A, args[0], &a_in);
            call_sgetrf(&params);
            not_ok = params.INFO;
            if (not_ok) {
                error_occurred = 1;
                nan_FLOAT_matrix(args[1], &f_out);
            } else {
                delinearize_FLOAT_matrix(args[1], params.A, &f_out);
                delinearize_INT_vec(args[2], params.IPIV, &ipiv_out);
            }
        END_OUTER_LOOP_3
        release_sgetrf(&params);
    }
    set_fp_invalid_or_clear(error_occurred);
}

/*
******************************************************************************
**                                SOLVE                                     **
******************************************************************************
*/

// solve_signature = "(n,n),(n,nrhs)->(n,nrhs)";
// rsolve_signature = (nrhs,n),(n,n)->(nrhs,n)"

/******************************************
*   Calling BLAS/Lapack functions _gesv   *
*******************************************/

static NPY_INLINE void
call_sgesv(GESV_PARAMS_t *params)
{
    // A,B are modified by ?GESV to carry LU info & X
    LAPACK(sgesv)(&params->N, &params->NRHS, params->A, &params->LDA,
                   params->IPIV, params->B, &params->LDB, &params->INFO);
}

/***************************************************************************
* Initialize the parameters to use in the lapack functions _gesv           *
* Handles buffer allocation
****************************************************************************/
static NPY_INLINE int
init_sgesv(GESV_PARAMS_t *params, npy_intp N_in, npy_intp NRHS_in, char trans)
{
    npy_uint8 *mem_buff = NULL;
    npy_uint8 *a, *b, *c;
    fortran_int N, NRHS, lda, ldb;
    size_t safe_N, safe_NRHS;

    N = (fortran_int)N_in;
    NRHS = (fortran_int)NRHS_in;
    lda = fortran_int_max(N, 1);
    ldb = fortran_int_max(N, 1);
    safe_N = N_in;
    safe_NRHS = NRHS_in;

    mem_buff = malloc(safe_N * safe_N * sizeof(fortran_real)
                    + safe_N * safe_NRHS * sizeof(fortran_real)
                    + safe_N * sizeof(fortran_int));
    if (!mem_buff) {
        goto error;
    }
    a = mem_buff;
    b = a + safe_N * safe_N * sizeof(fortran_real);
    c = b + safe_N * safe_NRHS * sizeof(fortran_real);

    params->A = a;
    params->B = b;
    params->IPIV = (fortran_int*)c;
    params->M = N;
    params->N = N;
    params->NRHS = NRHS;
    params->LDA = lda;
    params->LDB = ldb;
    params->INFO = 0;
    params->TRANS = trans;

    return 1;

  error:
    free(mem_buff);
    memset(params, 0, sizeof(*params));
    // PyErr_NoMemory();

    return 0;
}

// /************************
// * Deallocate buffer     *
// *************************/
//
// static NPY_INLINE void
// release_sgesv(GESV_PARAMS_t *params)
// {
//     /* 1st memory block base is in A */
//     free(params->A);
//     memset(params, 0, sizeof(*params));
// }


/************************
* Inner GUfunc loop     *
*************************/

// solve_signature = "(n,n),(n,nrhs)->(n,nrhs)";

static void
FLOAT_solve(char **args, npy_intp *dimensions, npy_intp *steps,
            void *NPY_UNUSED(func))
{
    INIT_OUTER_LOOP_3
    npy_intp len_n = *dimensions++;  // rows
    npy_intp len_nrhs = *dimensions++;  // columns
    npy_intp stride_a_r = *steps++;  // rows
    npy_intp stride_a_c = *steps++;
    npy_intp stride_b_r = *steps++;  // rows
    npy_intp stride_b_c = *steps++;
    npy_intp stride_x_r = *steps++;  // rows
    npy_intp stride_x_c = *steps++;
    int error_occurred = get_fp_invalid_and_clear();
    GESV_PARAMS_t params;
    LINEARIZE_DATA_t a_in, b_in, x_out;

    if(init_sgesv(&params, len_n, len_nrhs, 'N')){
        init_linearize_data(&a_in, len_n, len_n, stride_a_c, stride_a_r);
        init_linearize_data(&b_in, len_nrhs, len_n, stride_b_c, stride_b_r);
        init_linearize_data(&x_out, len_nrhs, len_n, stride_x_c, stride_x_r);

        BEGIN_OUTER_LOOP
            int not_ok;
            linearize_FLOAT_matrix(params.A, args[0], &a_in);
            linearize_FLOAT_matrix(params.B, args[1], &b_in);
            call_sgesv(&params);
            not_ok = params.INFO;
            if (not_ok) {
                error_occurred = 1;
                nan_FLOAT_matrix(args[2], &x_out);
            } else {
                delinearize_FLOAT_matrix(args[2], params.B, &x_out);
            }
        END_OUTER_LOOP_3
        release_sgetrf(&params);
    }
    set_fp_invalid_or_clear(error_occurred);
}

/*************
* RSOLVE     *
**************/

// rsolve_signature = (nrhs,n),(n,n)->(nrhs,n)"

static void
FLOAT_rsolve(char **args, npy_intp *dimensions, npy_intp *steps,
            void *NPY_UNUSED(func))
{
    /*swap (A,B) for (B^T,A^T)
    a,b here are not the same as A,B  in docstring: a=B^T, b=A^T */
    char *rargs[] = {args[1], args[0], args[2]};
    // dimensions = {N, len_nrhs, len_n};
    // rdimensions[] = {N, len_n, len_nrhs};
    npy_intp rdimensions[] = {dimensions[0], dimensions[2], dimensions[1]};
    // steps = {strides_b, strides_a, strides_x,
    //     strides_b_c, strides_b_r,
    //     strides_a_c, strides_a_r,
    //     strides_x_c, strides_x_r, };
    // rsteps = {strides_a, strides_b, strides_x,
    //     strides_a_r, strides_a_c,
    //     strides_b_r, strides_b_c,
    //     strides_x_r, strides_x_c, };
    npy_intp rsteps[] = {steps[1], steps[0], steps[2],
            steps[6], steps[5],
            steps[4], steps[3],
            steps[8], steps[7]};
    //now that we've swapped a,b and transposed, proceed as if we're in solve
    FLOAT_solve(rargs, rdimensions, rsteps, NULL);
}

/***********************************************************
**                       SOLVE with LU                    **
************************************************************/

// solvelu_signature = "(n,n),(n,nrhs)->(n,nrhs),(n,n),(n)";
// rsolvelu_signature = "(nrhs,n),(n,n)->(nrhs,n),(n,n),(n)";
// lusolve_signature = "(n,n),(n),(n,nrhs)->(n,nrhs)";
// rlusolve_signature = "(nrhs,n),(n,n),(n)->(nrhs,n)";

/*******************************************
*   Calling BLAS/Lapack functions _getrs   *
********************************************/

static NPY_INLINE void
call_sgetrs(GESV_PARAMS_t *params)
{
    // B is modified by ?GETRS to carry X
    LAPACK(sgetrs)(&params->TRANS, &params->N, &params->NRHS,
                    params->A, &params->LDA, params->IPIV,
                    params->B, &params->LDB, &params->INFO);
}


/************************
* Inner GUfunc loop     *
*************************/

// solvelu_signature = "(n,n),(n,nrhs)->(n,nrhs),(n,n),(n)";

static void
FLOAT_solvelu_loop(char **args, npy_intp *dimensions, npy_intp *steps, char trans)
{
    INIT_OUTER_LOOP_5
    npy_intp len_n = *dimensions++;  // rows
    npy_intp len_nrhs = *dimensions++;  // columns
    npy_intp stride_a_r = *steps++;  // rows, a
    npy_intp stride_a_c = *steps++;
    npy_intp stride_b_r = *steps++;  // rows, b
    npy_intp stride_b_c = *steps++;
    npy_intp stride_x_r = *steps++;  // rows, x = a\b
    npy_intp stride_x_c = *steps++;
    npy_intp stride_af_r = *steps++;  // rows, LU factors of a
    npy_intp stride_af_c = *steps++;
    npy_intp stride_ip = *steps++;  // vec, permutations, a = PLU
    int error_occurred = get_fp_invalid_and_clear();
    GESV_PARAMS_t params;
    LINEARIZE_DATA_t a_in, b_in, x_out, af_out, ipiv_out;

    if(init_sgesv(&params, len_n, len_nrhs, trans)){
        init_linearize_data(&a_in, len_n, len_n, stride_a_c, stride_a_r);
        init_linearize_data(&b_in, len_nrhs, len_n, stride_b_c, stride_b_r);
        init_linearize_data(&x_out, len_nrhs, len_n, stride_x_c, stride_x_r);
        init_linearize_data(&af_out, len_n, len_n, stride_af_c, stride_af_r);
        init_linearize_vdata(&ipiv_out, len_n, stride_ip);

        BEGIN_OUTER_LOOP_5
            int not_ok;
            linearize_FLOAT_matrix(params.A, args[0], &a_in);
            linearize_FLOAT_matrix(params.B, args[1], &b_in);
            call_sgetrf(&params);
            call_sgetrs(&params);
            not_ok = params.INFO;
            if (not_ok) {
                error_occurred = 1;
                nan_FLOAT_matrix(args[2], &x_out);
                nan_FLOAT_matrix(args[3], &af_out);
            } else {
                delinearize_FLOAT_matrix(args[2], params.B, &x_out);
                delinearize_FLOAT_matrix(args[3], params.A, &af_out);
                delinearize_INT_vec(args[4], params.IPIV, &ipiv_out);
            }
        END_OUTER_LOOP_5
        release_sgetrf(&params);
    }
    set_fp_invalid_or_clear(error_occurred);
}

// solvelu_signature = "(n,n),(n,nrhs)->(n,nrhs),(n,n),(n)";

static void
FLOAT_solve_lu(char **args, npy_intp *dimensions, npy_intp *steps,
            void *NPY_UNUSED(func))
{
    FLOAT_solvelu_loop(args, dimensions, steps, 'N');
}

/*************
* RSOLVELU   *
**************/

// rsolvelu_signature = "(nrhs,n),(n,n)->(nrhs,n),(n,n),(n)";

static void
FLOAT_rsolve_lu(char **args, npy_intp *dimensions, npy_intp *steps,
            void *NPY_UNUSED(func))
{
    /*swap (A,B,X,Af,P) for (B^T,A,X^T,Af,P)
    a,b here are not the same as A,B  in docstring: a=B^T, b=A^T */
    char *rargs[] = {args[1], args[0], args[2], args[3], args[4]};
    // dimensions = {N, len_nrhs, len_n};
    // rdimensions[] = {N, len_n, len_nrhs};
    npy_intp rdimensions[] = {dimensions[0], dimensions[2], dimensions[1]};
    // steps = {strides_b, strides_a, strides_x, strides_af, strides_p,    0-4
    //     strides_b_c, strides_b_r,                5-6
    //     strides_a_r, strides_a_c,                7-8
    //     strides_x_c, strides_x_r,                9-10
    //     strides_af_r, strides_af_c, strides_ip}; 11-13
    // rsteps = {strides_a, strides_b, strides_x,
    //     strides_a_r, strides_a_c,
    //     strides_b_r, strides_b_c,
    //     strides_x_r, strides_x_c,
    //     strides_af_r, strides_af_c, strides_ip};
    npy_intp rsteps[] = {steps[1], steps[0], steps[2], steps[3], steps[4],
            steps[7], steps[8],
            steps[6], steps[5],
            steps[10], steps[9],
            steps[11], steps[12], steps[13]};
    //now that we've swapped a,b and transposed, proceed as if we're in solve
    FLOAT_solvelu_loop(rargs, rdimensions, rsteps, 'T');
}

/*************
* LUSOLVE    *
**************/

// lusolve_signature = "(n,n),(n),(n,nrhs)->(n,nrhs)";

static void
FLOAT_lusolve_loop(char **args, npy_intp *dimensions, npy_intp *steps, char trans)
{
    INIT_OUTER_LOOP_4
    npy_intp len_n = *dimensions++;  // rows
    npy_intp len_nrhs = *dimensions++;  // columns
    npy_intp stride_af_r = *steps++;  // rows, LU factors of a
    npy_intp stride_af_c = *steps++;
    npy_intp stride_ip = *steps++;  // vec, permutations, a = PLU
    npy_intp stride_b_r = *steps++;  // rows, b
    npy_intp stride_b_c = *steps++;
    npy_intp stride_x_r = *steps++;  // rows, x = a\b
    npy_intp stride_x_c = *steps++;
    int error_occurred = get_fp_invalid_and_clear();
    GESV_PARAMS_t params;
    LINEARIZE_DATA_t a_in, b_in, x_out, ipiv_in;

    if(init_sgesv(&params, len_n, len_nrhs, trans)){
        init_linearize_data(&a_in, len_n, len_n, stride_af_c, stride_af_r);
        init_linearize_vdata(&ipiv_in, len_n, stride_ip);
        init_linearize_data(&b_in, len_nrhs, len_n, stride_b_c, stride_b_r);
        init_linearize_data(&x_out, len_nrhs, len_n, stride_x_c, stride_x_r);

        BEGIN_OUTER_LOOP_4
            int not_ok;
            linearize_FLOAT_matrix(params.A, args[0], &a_in);
            linearize_INT_vec(params.IPIV, args[1], &ipiv_in);
            linearize_FLOAT_matrix(params.B, args[2], &b_in);
            call_sgetrs(&params);
            not_ok = params.INFO;
            if (not_ok) {
                error_occurred = 1;
                nan_FLOAT_matrix(args[3], &x_out);
            } else {
                delinearize_FLOAT_matrix(args[3], params.B, &x_out);
            }
        END_OUTER_LOOP_4
        release_sgetrf(&params);
    }
    set_fp_invalid_or_clear(error_occurred);
}

// lusolve_signature = "(n,n),(n),(n,nrhs)->(n,nrhs)";

static void
FLOAT_lu_solve(char **args, npy_intp *dimensions, npy_intp *steps,
            void *NPY_UNUSED(func))
{
    FLOAT_lusolve_loop(args, dimensions, steps, 'N');
}

/*************
* RLUSOLVE   *
**************/

// rlusolve_signature = "(nrhs,n),(n,n),(n)->(nrhs,n)";

static void
FLOAT_rlu_solve(char **args, npy_intp *dimensions, npy_intp *steps,
            void *NPY_UNUSED(func))
{
    /*swap (A,P,B,X) for (B^T,A,P,X^T)
    a,b here are not the same as A,B  in docstring: a=B^T, b=A^T */
    char *rargs[] = {args[1], args[2], args[0], args[3]};
    // dimensions = {N, len_nrhs, len_n};
    // rdimensions[] = {N, len_n, len_nrhs};
    npy_intp rdimensions[] = {dimensions[0], dimensions[2], dimensions[1]};
    // steps = {strides_b, strides_a, strides_p, strides_x, 0-3
    //     strides_b_c, strides_b_r,                        4-5
    //     strides_a_r, strides_a_c, strides_ip             6-8
    //     strides_x_c, strides_x_r};                       9-10
    // rsteps = {strides_a, strides_p, strides_b, strides_x,
    //     strides_a_r, strides_a_c, strides_ip
    //     strides_b_r, strides_b_c,
    //     strides_x_r, strides_x_c};
    npy_intp rsteps[] = {steps[1], steps[2], steps[0], steps[3],
            steps[6], steps[7], steps[8],
            steps[5], steps[4],
            steps[10], steps[9]};
    //now that we've swapped a,b and transposed, proceed as if we're in solve
    FLOAT_lusolve_loop(rargs, rdimensions, rsteps, 'T');
}


#line 263

// lu_signature = "(m,n)->(m,k),(k,n),(k)"
// lu_raw_signature = "(m,n)->(m,n),(k)"
/**************************************************
* Calling BLAS/Lapack function _getrf *
***************************************************/

static NPY_INLINE void
call_dgetrf(GESV_PARAMS_t *params)
{
    // A is modified by ?GETRF to carry LU info
    LAPACK(dgetrf)(&params->M, &params->N, params->A, &params->LDA,
                    params->IPIV, &params->INFO);
}

/***************************************************************************
* Initialize the parameters to use in the lapack functions _gesv           *
* Handles buffer allocation
****************************************************************************/
static NPY_INLINE int
init_dgetrf(GESV_PARAMS_t *params, npy_intp M_in, npy_intp N_in)
{
    npy_uint8 *mem_buff = NULL;
    npy_uint8 *a, *b;
    fortran_int M, N, K, lda;
    size_t safe_M, safe_N, safe_K;

    M = (fortran_int)M_in;
    N = (fortran_int)N_in;
    K = fortran_int_min(M, N);
    lda = fortran_int_max(M, 1);
    safe_N = M_in;
    safe_N = N_in;
    safe_K = K;

    mem_buff = malloc(safe_M * safe_N * sizeof(fortran_doublereal)
                    + safe_K * sizeof(fortran_int));
    if (!mem_buff) {
        goto error;
    }
    a = mem_buff;
    b = a + safe_M * safe_N * sizeof(fortran_doublereal);

    params->A = a;
    params->B = NULL;
    params->IPIV = (fortran_int*)b;
    params->M = M;
    params->N = N;
    params->NRHS = N;
    params->LDA = lda;
    params->LDB = 1;
    params->INFO = 0;
    params->TRANS = 'N';

    return 1;

  error:
    free(mem_buff);
    memset(params, 0, sizeof(*params));
    // PyErr_NoMemory();

    return 0;
}

/************************
* Deallocate buffer     *
*************************/

static NPY_INLINE void
release_dgetrf(GESV_PARAMS_t *params)
{
    /* 1st memory block base is in A */
    free(params->A);
    memset(params, 0, sizeof(*params));
}

/************************
* Inner GUfunc loop     *
*************************/

// lu_signature = "(m,n)->(m,k),(k,n),(k)"

static void
DOUBLE_lu(char **args, npy_intp *dimensions, npy_intp *steps,
            void *NPY_UNUSED(func))
{
    INIT_OUTER_LOOP_4
    npy_intp len_m = *dimensions++;  // rows
    npy_intp len_n = *dimensions++;  // columns
    npy_intp stride_a_r = *steps++;  // rows
    npy_intp stride_a_c = *steps++;
    npy_intp stride_l_r = *steps++;  // rows
    npy_intp stride_l_c = *steps++;
    npy_intp stride_u_r = *steps++;  // rows
    npy_intp stride_u_c = *steps++;
    npy_intp stride_ip = *steps++;  // elements
    int error_occurred = get_fp_invalid_and_clear();
    GESV_PARAMS_t params;
    LINEARIZE_DATA_t a_in, l_out, u_out, ipiv_out;
    npy_intp len_k = npy_int_min(len_m, len_n);

    if(init_dgetrf(&params, len_m, len_n)) {
        init_linearize_data(&a_in, len_n, len_m, stride_a_c, stride_a_r);
        init_linearize_data(&l_out, len_k, len_m, stride_l_c, stride_l_r);
        init_linearize_data_ex(&u_out, len_n, len_k, stride_u_c, stride_u_r, len_m);
        init_linearize_vdata(&ipiv_out, len_k, stride_ip);

        BEGIN_OUTER_LOOP_4
            int not_ok;
            linearize_DOUBLE_matrix(params.A, args[0], &a_in);
            call_dgetrf(&params);
            not_ok = params.INFO;
            if (not_ok) {
                error_occurred = 1;
                nan_DOUBLE_matrix(args[1], &l_out);
                nan_DOUBLE_matrix(args[2], &u_out);
            } else {
                zero_DOUBLE_matrix(args[1], &l_out);
                eye_DOUBLE_matrix(args[1], &l_out);
                delinearize_DOUBLE_tril(args[1], params.A, &l_out);
                zero_DOUBLE_matrix(args[2], &u_out);
                delinearize_DOUBLE_triu(args[2], params.A, &u_out);
                delinearize_INT_vec(args[3], params.IPIV, &ipiv_out);
            }
        END_OUTER_LOOP_4
        release_dgetrf(&params);
    }
    set_fp_invalid_or_clear(error_occurred);
}

/************************
*         LU RAW        *
*************************/

// lu_raw_signature = "(m,n)->(m,n),(k)"

static void
DOUBLE_lu_raw(char **args, npy_intp *dimensions, npy_intp *steps,
            void *NPY_UNUSED(func))
{
    INIT_OUTER_LOOP_3
    npy_intp len_m = *dimensions++;  // rows
    npy_intp len_n = *dimensions++;  // columns
    npy_intp stride_a_r = *steps++;  // rows
    npy_intp stride_a_c = *steps++;
    npy_intp stride_f_r = *steps++;  // rows
    npy_intp stride_f_c = *steps++;
    npy_intp stride_ip = *steps++;  // elements
    int error_occurred = get_fp_invalid_and_clear();
    GESV_PARAMS_t params;
    LINEARIZE_DATA_t a_in, f_out, ipiv_out;
    npy_intp len_k = npy_int_min(len_m, len_n);

    if(init_dgetrf(&params, len_m, len_n)) {
        init_linearize_data(&a_in, len_n, len_m, stride_a_c, stride_a_r);
        init_linearize_data(&f_out, len_n, len_m, stride_f_c, stride_f_r);
        init_linearize_vdata(&ipiv_out, len_k, stride_ip);

        BEGIN_OUTER_LOOP_3
            int not_ok;
            linearize_DOUBLE_matrix(params.A, args[0], &a_in);
            call_dgetrf(&params);
            not_ok = params.INFO;
            if (not_ok) {
                error_occurred = 1;
                nan_DOUBLE_matrix(args[1], &f_out);
            } else {
                delinearize_DOUBLE_matrix(args[1], params.A, &f_out);
                delinearize_INT_vec(args[2], params.IPIV, &ipiv_out);
            }
        END_OUTER_LOOP_3
        release_dgetrf(&params);
    }
    set_fp_invalid_or_clear(error_occurred);
}

/*
******************************************************************************
**                                SOLVE                                     **
******************************************************************************
*/

// solve_signature = "(n,n),(n,nrhs)->(n,nrhs)";
// rsolve_signature = (nrhs,n),(n,n)->(nrhs,n)"

/******************************************
*   Calling BLAS/Lapack functions _gesv   *
*******************************************/

static NPY_INLINE void
call_dgesv(GESV_PARAMS_t *params)
{
    // A,B are modified by ?GESV to carry LU info & X
    LAPACK(dgesv)(&params->N, &params->NRHS, params->A, &params->LDA,
                   params->IPIV, params->B, &params->LDB, &params->INFO);
}

/***************************************************************************
* Initialize the parameters to use in the lapack functions _gesv           *
* Handles buffer allocation
****************************************************************************/
static NPY_INLINE int
init_dgesv(GESV_PARAMS_t *params, npy_intp N_in, npy_intp NRHS_in, char trans)
{
    npy_uint8 *mem_buff = NULL;
    npy_uint8 *a, *b, *c;
    fortran_int N, NRHS, lda, ldb;
    size_t safe_N, safe_NRHS;

    N = (fortran_int)N_in;
    NRHS = (fortran_int)NRHS_in;
    lda = fortran_int_max(N, 1);
    ldb = fortran_int_max(N, 1);
    safe_N = N_in;
    safe_NRHS = NRHS_in;

    mem_buff = malloc(safe_N * safe_N * sizeof(fortran_doublereal)
                    + safe_N * safe_NRHS * sizeof(fortran_doublereal)
                    + safe_N * sizeof(fortran_int));
    if (!mem_buff) {
        goto error;
    }
    a = mem_buff;
    b = a + safe_N * safe_N * sizeof(fortran_doublereal);
    c = b + safe_N * safe_NRHS * sizeof(fortran_doublereal);

    params->A = a;
    params->B = b;
    params->IPIV = (fortran_int*)c;
    params->M = N;
    params->N = N;
    params->NRHS = NRHS;
    params->LDA = lda;
    params->LDB = ldb;
    params->INFO = 0;
    params->TRANS = trans;

    return 1;

  error:
    free(mem_buff);
    memset(params, 0, sizeof(*params));
    // PyErr_NoMemory();

    return 0;
}

// /************************
// * Deallocate buffer     *
// *************************/
//
// static NPY_INLINE void
// release_dgesv(GESV_PARAMS_t *params)
// {
//     /* 1st memory block base is in A */
//     free(params->A);
//     memset(params, 0, sizeof(*params));
// }


/************************
* Inner GUfunc loop     *
*************************/

// solve_signature = "(n,n),(n,nrhs)->(n,nrhs)";

static void
DOUBLE_solve(char **args, npy_intp *dimensions, npy_intp *steps,
            void *NPY_UNUSED(func))
{
    INIT_OUTER_LOOP_3
    npy_intp len_n = *dimensions++;  // rows
    npy_intp len_nrhs = *dimensions++;  // columns
    npy_intp stride_a_r = *steps++;  // rows
    npy_intp stride_a_c = *steps++;
    npy_intp stride_b_r = *steps++;  // rows
    npy_intp stride_b_c = *steps++;
    npy_intp stride_x_r = *steps++;  // rows
    npy_intp stride_x_c = *steps++;
    int error_occurred = get_fp_invalid_and_clear();
    GESV_PARAMS_t params;
    LINEARIZE_DATA_t a_in, b_in, x_out;

    if(init_dgesv(&params, len_n, len_nrhs, 'N')){
        init_linearize_data(&a_in, len_n, len_n, stride_a_c, stride_a_r);
        init_linearize_data(&b_in, len_nrhs, len_n, stride_b_c, stride_b_r);
        init_linearize_data(&x_out, len_nrhs, len_n, stride_x_c, stride_x_r);

        BEGIN_OUTER_LOOP
            int not_ok;
            linearize_DOUBLE_matrix(params.A, args[0], &a_in);
            linearize_DOUBLE_matrix(params.B, args[1], &b_in);
            call_dgesv(&params);
            not_ok = params.INFO;
            if (not_ok) {
                error_occurred = 1;
                nan_DOUBLE_matrix(args[2], &x_out);
            } else {
                delinearize_DOUBLE_matrix(args[2], params.B, &x_out);
            }
        END_OUTER_LOOP_3
        release_dgetrf(&params);
    }
    set_fp_invalid_or_clear(error_occurred);
}

/*************
* RSOLVE     *
**************/

// rsolve_signature = (nrhs,n),(n,n)->(nrhs,n)"

static void
DOUBLE_rsolve(char **args, npy_intp *dimensions, npy_intp *steps,
            void *NPY_UNUSED(func))
{
    /*swap (A,B) for (B^T,A^T)
    a,b here are not the same as A,B  in docstring: a=B^T, b=A^T */
    char *rargs[] = {args[1], args[0], args[2]};
    // dimensions = {N, len_nrhs, len_n};
    // rdimensions[] = {N, len_n, len_nrhs};
    npy_intp rdimensions[] = {dimensions[0], dimensions[2], dimensions[1]};
    // steps = {strides_b, strides_a, strides_x,
    //     strides_b_c, strides_b_r,
    //     strides_a_c, strides_a_r,
    //     strides_x_c, strides_x_r, };
    // rsteps = {strides_a, strides_b, strides_x,
    //     strides_a_r, strides_a_c,
    //     strides_b_r, strides_b_c,
    //     strides_x_r, strides_x_c, };
    npy_intp rsteps[] = {steps[1], steps[0], steps[2],
            steps[6], steps[5],
            steps[4], steps[3],
            steps[8], steps[7]};
    //now that we've swapped a,b and transposed, proceed as if we're in solve
    DOUBLE_solve(rargs, rdimensions, rsteps, NULL);
}

/***********************************************************
**                       SOLVE with LU                    **
************************************************************/

// solvelu_signature = "(n,n),(n,nrhs)->(n,nrhs),(n,n),(n)";
// rsolvelu_signature = "(nrhs,n),(n,n)->(nrhs,n),(n,n),(n)";
// lusolve_signature = "(n,n),(n),(n,nrhs)->(n,nrhs)";
// rlusolve_signature = "(nrhs,n),(n,n),(n)->(nrhs,n)";

/*******************************************
*   Calling BLAS/Lapack functions _getrs   *
********************************************/

static NPY_INLINE void
call_dgetrs(GESV_PARAMS_t *params)
{
    // B is modified by ?GETRS to carry X
    LAPACK(dgetrs)(&params->TRANS, &params->N, &params->NRHS,
                    params->A, &params->LDA, params->IPIV,
                    params->B, &params->LDB, &params->INFO);
}


/************************
* Inner GUfunc loop     *
*************************/

// solvelu_signature = "(n,n),(n,nrhs)->(n,nrhs),(n,n),(n)";

static void
DOUBLE_solvelu_loop(char **args, npy_intp *dimensions, npy_intp *steps, char trans)
{
    INIT_OUTER_LOOP_5
    npy_intp len_n = *dimensions++;  // rows
    npy_intp len_nrhs = *dimensions++;  // columns
    npy_intp stride_a_r = *steps++;  // rows, a
    npy_intp stride_a_c = *steps++;
    npy_intp stride_b_r = *steps++;  // rows, b
    npy_intp stride_b_c = *steps++;
    npy_intp stride_x_r = *steps++;  // rows, x = a\b
    npy_intp stride_x_c = *steps++;
    npy_intp stride_af_r = *steps++;  // rows, LU factors of a
    npy_intp stride_af_c = *steps++;
    npy_intp stride_ip = *steps++;  // vec, permutations, a = PLU
    int error_occurred = get_fp_invalid_and_clear();
    GESV_PARAMS_t params;
    LINEARIZE_DATA_t a_in, b_in, x_out, af_out, ipiv_out;

    if(init_dgesv(&params, len_n, len_nrhs, trans)){
        init_linearize_data(&a_in, len_n, len_n, stride_a_c, stride_a_r);
        init_linearize_data(&b_in, len_nrhs, len_n, stride_b_c, stride_b_r);
        init_linearize_data(&x_out, len_nrhs, len_n, stride_x_c, stride_x_r);
        init_linearize_data(&af_out, len_n, len_n, stride_af_c, stride_af_r);
        init_linearize_vdata(&ipiv_out, len_n, stride_ip);

        BEGIN_OUTER_LOOP_5
            int not_ok;
            linearize_DOUBLE_matrix(params.A, args[0], &a_in);
            linearize_DOUBLE_matrix(params.B, args[1], &b_in);
            call_dgetrf(&params);
            call_dgetrs(&params);
            not_ok = params.INFO;
            if (not_ok) {
                error_occurred = 1;
                nan_DOUBLE_matrix(args[2], &x_out);
                nan_DOUBLE_matrix(args[3], &af_out);
            } else {
                delinearize_DOUBLE_matrix(args[2], params.B, &x_out);
                delinearize_DOUBLE_matrix(args[3], params.A, &af_out);
                delinearize_INT_vec(args[4], params.IPIV, &ipiv_out);
            }
        END_OUTER_LOOP_5
        release_dgetrf(&params);
    }
    set_fp_invalid_or_clear(error_occurred);
}

// solvelu_signature = "(n,n),(n,nrhs)->(n,nrhs),(n,n),(n)";

static void
DOUBLE_solve_lu(char **args, npy_intp *dimensions, npy_intp *steps,
            void *NPY_UNUSED(func))
{
    DOUBLE_solvelu_loop(args, dimensions, steps, 'N');
}

/*************
* RSOLVELU   *
**************/

// rsolvelu_signature = "(nrhs,n),(n,n)->(nrhs,n),(n,n),(n)";

static void
DOUBLE_rsolve_lu(char **args, npy_intp *dimensions, npy_intp *steps,
            void *NPY_UNUSED(func))
{
    /*swap (A,B,X,Af,P) for (B^T,A,X^T,Af,P)
    a,b here are not the same as A,B  in docstring: a=B^T, b=A^T */
    char *rargs[] = {args[1], args[0], args[2], args[3], args[4]};
    // dimensions = {N, len_nrhs, len_n};
    // rdimensions[] = {N, len_n, len_nrhs};
    npy_intp rdimensions[] = {dimensions[0], dimensions[2], dimensions[1]};
    // steps = {strides_b, strides_a, strides_x, strides_af, strides_p,    0-4
    //     strides_b_c, strides_b_r,                5-6
    //     strides_a_r, strides_a_c,                7-8
    //     strides_x_c, strides_x_r,                9-10
    //     strides_af_r, strides_af_c, strides_ip}; 11-13
    // rsteps = {strides_a, strides_b, strides_x,
    //     strides_a_r, strides_a_c,
    //     strides_b_r, strides_b_c,
    //     strides_x_r, strides_x_c,
    //     strides_af_r, strides_af_c, strides_ip};
    npy_intp rsteps[] = {steps[1], steps[0], steps[2], steps[3], steps[4],
            steps[7], steps[8],
            steps[6], steps[5],
            steps[10], steps[9],
            steps[11], steps[12], steps[13]};
    //now that we've swapped a,b and transposed, proceed as if we're in solve
    DOUBLE_solvelu_loop(rargs, rdimensions, rsteps, 'T');
}

/*************
* LUSOLVE    *
**************/

// lusolve_signature = "(n,n),(n),(n,nrhs)->(n,nrhs)";

static void
DOUBLE_lusolve_loop(char **args, npy_intp *dimensions, npy_intp *steps, char trans)
{
    INIT_OUTER_LOOP_4
    npy_intp len_n = *dimensions++;  // rows
    npy_intp len_nrhs = *dimensions++;  // columns
    npy_intp stride_af_r = *steps++;  // rows, LU factors of a
    npy_intp stride_af_c = *steps++;
    npy_intp stride_ip = *steps++;  // vec, permutations, a = PLU
    npy_intp stride_b_r = *steps++;  // rows, b
    npy_intp stride_b_c = *steps++;
    npy_intp stride_x_r = *steps++;  // rows, x = a\b
    npy_intp stride_x_c = *steps++;
    int error_occurred = get_fp_invalid_and_clear();
    GESV_PARAMS_t params;
    LINEARIZE_DATA_t a_in, b_in, x_out, ipiv_in;

    if(init_dgesv(&params, len_n, len_nrhs, trans)){
        init_linearize_data(&a_in, len_n, len_n, stride_af_c, stride_af_r);
        init_linearize_vdata(&ipiv_in, len_n, stride_ip);
        init_linearize_data(&b_in, len_nrhs, len_n, stride_b_c, stride_b_r);
        init_linearize_data(&x_out, len_nrhs, len_n, stride_x_c, stride_x_r);

        BEGIN_OUTER_LOOP_4
            int not_ok;
            linearize_DOUBLE_matrix(params.A, args[0], &a_in);
            linearize_INT_vec(params.IPIV, args[1], &ipiv_in);
            linearize_DOUBLE_matrix(params.B, args[2], &b_in);
            call_dgetrs(&params);
            not_ok = params.INFO;
            if (not_ok) {
                error_occurred = 1;
                nan_DOUBLE_matrix(args[3], &x_out);
            } else {
                delinearize_DOUBLE_matrix(args[3], params.B, &x_out);
            }
        END_OUTER_LOOP_4
        release_dgetrf(&params);
    }
    set_fp_invalid_or_clear(error_occurred);
}

// lusolve_signature = "(n,n),(n),(n,nrhs)->(n,nrhs)";

static void
DOUBLE_lu_solve(char **args, npy_intp *dimensions, npy_intp *steps,
            void *NPY_UNUSED(func))
{
    DOUBLE_lusolve_loop(args, dimensions, steps, 'N');
}

/*************
* RLUSOLVE   *
**************/

// rlusolve_signature = "(nrhs,n),(n,n),(n)->(nrhs,n)";

static void
DOUBLE_rlu_solve(char **args, npy_intp *dimensions, npy_intp *steps,
            void *NPY_UNUSED(func))
{
    /*swap (A,P,B,X) for (B^T,A,P,X^T)
    a,b here are not the same as A,B  in docstring: a=B^T, b=A^T */
    char *rargs[] = {args[1], args[2], args[0], args[3]};
    // dimensions = {N, len_nrhs, len_n};
    // rdimensions[] = {N, len_n, len_nrhs};
    npy_intp rdimensions[] = {dimensions[0], dimensions[2], dimensions[1]};
    // steps = {strides_b, strides_a, strides_p, strides_x, 0-3
    //     strides_b_c, strides_b_r,                        4-5
    //     strides_a_r, strides_a_c, strides_ip             6-8
    //     strides_x_c, strides_x_r};                       9-10
    // rsteps = {strides_a, strides_p, strides_b, strides_x,
    //     strides_a_r, strides_a_c, strides_ip
    //     strides_b_r, strides_b_c,
    //     strides_x_r, strides_x_c};
    npy_intp rsteps[] = {steps[1], steps[2], steps[0], steps[3],
            steps[6], steps[7], steps[8],
            steps[5], steps[4],
            steps[10], steps[9]};
    //now that we've swapped a,b and transposed, proceed as if we're in solve
    DOUBLE_lusolve_loop(rargs, rdimensions, rsteps, 'T');
}


#line 263

// lu_signature = "(m,n)->(m,k),(k,n),(k)"
// lu_raw_signature = "(m,n)->(m,n),(k)"
/**************************************************
* Calling BLAS/Lapack function _getrf *
***************************************************/

static NPY_INLINE void
call_cgetrf(GESV_PARAMS_t *params)
{
    // A is modified by ?GETRF to carry LU info
    LAPACK(cgetrf)(&params->M, &params->N, params->A, &params->LDA,
                    params->IPIV, &params->INFO);
}

/***************************************************************************
* Initialize the parameters to use in the lapack functions _gesv           *
* Handles buffer allocation
****************************************************************************/
static NPY_INLINE int
init_cgetrf(GESV_PARAMS_t *params, npy_intp M_in, npy_intp N_in)
{
    npy_uint8 *mem_buff = NULL;
    npy_uint8 *a, *b;
    fortran_int M, N, K, lda;
    size_t safe_M, safe_N, safe_K;

    M = (fortran_int)M_in;
    N = (fortran_int)N_in;
    K = fortran_int_min(M, N);
    lda = fortran_int_max(M, 1);
    safe_N = M_in;
    safe_N = N_in;
    safe_K = K;

    mem_buff = malloc(safe_M * safe_N * sizeof(fortran_complex)
                    + safe_K * sizeof(fortran_int));
    if (!mem_buff) {
        goto error;
    }
    a = mem_buff;
    b = a + safe_M * safe_N * sizeof(fortran_complex);

    params->A = a;
    params->B = NULL;
    params->IPIV = (fortran_int*)b;
    params->M = M;
    params->N = N;
    params->NRHS = N;
    params->LDA = lda;
    params->LDB = 1;
    params->INFO = 0;
    params->TRANS = 'N';

    return 1;

  error:
    free(mem_buff);
    memset(params, 0, sizeof(*params));
    // PyErr_NoMemory();

    return 0;
}

/************************
* Deallocate buffer     *
*************************/

static NPY_INLINE void
release_cgetrf(GESV_PARAMS_t *params)
{
    /* 1st memory block base is in A */
    free(params->A);
    memset(params, 0, sizeof(*params));
}

/************************
* Inner GUfunc loop     *
*************************/

// lu_signature = "(m,n)->(m,k),(k,n),(k)"

static void
CFLOAT_lu(char **args, npy_intp *dimensions, npy_intp *steps,
            void *NPY_UNUSED(func))
{
    INIT_OUTER_LOOP_4
    npy_intp len_m = *dimensions++;  // rows
    npy_intp len_n = *dimensions++;  // columns
    npy_intp stride_a_r = *steps++;  // rows
    npy_intp stride_a_c = *steps++;
    npy_intp stride_l_r = *steps++;  // rows
    npy_intp stride_l_c = *steps++;
    npy_intp stride_u_r = *steps++;  // rows
    npy_intp stride_u_c = *steps++;
    npy_intp stride_ip = *steps++;  // elements
    int error_occurred = get_fp_invalid_and_clear();
    GESV_PARAMS_t params;
    LINEARIZE_DATA_t a_in, l_out, u_out, ipiv_out;
    npy_intp len_k = npy_int_min(len_m, len_n);

    if(init_cgetrf(&params, len_m, len_n)) {
        init_linearize_data(&a_in, len_n, len_m, stride_a_c, stride_a_r);
        init_linearize_data(&l_out, len_k, len_m, stride_l_c, stride_l_r);
        init_linearize_data_ex(&u_out, len_n, len_k, stride_u_c, stride_u_r, len_m);
        init_linearize_vdata(&ipiv_out, len_k, stride_ip);

        BEGIN_OUTER_LOOP_4
            int not_ok;
            linearize_CFLOAT_matrix(params.A, args[0], &a_in);
            call_cgetrf(&params);
            not_ok = params.INFO;
            if (not_ok) {
                error_occurred = 1;
                nan_CFLOAT_matrix(args[1], &l_out);
                nan_CFLOAT_matrix(args[2], &u_out);
            } else {
                zero_CFLOAT_matrix(args[1], &l_out);
                eye_CFLOAT_matrix(args[1], &l_out);
                delinearize_CFLOAT_tril(args[1], params.A, &l_out);
                zero_CFLOAT_matrix(args[2], &u_out);
                delinearize_CFLOAT_triu(args[2], params.A, &u_out);
                delinearize_INT_vec(args[3], params.IPIV, &ipiv_out);
            }
        END_OUTER_LOOP_4
        release_cgetrf(&params);
    }
    set_fp_invalid_or_clear(error_occurred);
}

/************************
*         LU RAW        *
*************************/

// lu_raw_signature = "(m,n)->(m,n),(k)"

static void
CFLOAT_lu_raw(char **args, npy_intp *dimensions, npy_intp *steps,
            void *NPY_UNUSED(func))
{
    INIT_OUTER_LOOP_3
    npy_intp len_m = *dimensions++;  // rows
    npy_intp len_n = *dimensions++;  // columns
    npy_intp stride_a_r = *steps++;  // rows
    npy_intp stride_a_c = *steps++;
    npy_intp stride_f_r = *steps++;  // rows
    npy_intp stride_f_c = *steps++;
    npy_intp stride_ip = *steps++;  // elements
    int error_occurred = get_fp_invalid_and_clear();
    GESV_PARAMS_t params;
    LINEARIZE_DATA_t a_in, f_out, ipiv_out;
    npy_intp len_k = npy_int_min(len_m, len_n);

    if(init_cgetrf(&params, len_m, len_n)) {
        init_linearize_data(&a_in, len_n, len_m, stride_a_c, stride_a_r);
        init_linearize_data(&f_out, len_n, len_m, stride_f_c, stride_f_r);
        init_linearize_vdata(&ipiv_out, len_k, stride_ip);

        BEGIN_OUTER_LOOP_3
            int not_ok;
            linearize_CFLOAT_matrix(params.A, args[0], &a_in);
            call_cgetrf(&params);
            not_ok = params.INFO;
            if (not_ok) {
                error_occurred = 1;
                nan_CFLOAT_matrix(args[1], &f_out);
            } else {
                delinearize_CFLOAT_matrix(args[1], params.A, &f_out);
                delinearize_INT_vec(args[2], params.IPIV, &ipiv_out);
            }
        END_OUTER_LOOP_3
        release_cgetrf(&params);
    }
    set_fp_invalid_or_clear(error_occurred);
}

/*
******************************************************************************
**                                SOLVE                                     **
******************************************************************************
*/

// solve_signature = "(n,n),(n,nrhs)->(n,nrhs)";
// rsolve_signature = (nrhs,n),(n,n)->(nrhs,n)"

/******************************************
*   Calling BLAS/Lapack functions _gesv   *
*******************************************/

static NPY_INLINE void
call_cgesv(GESV_PARAMS_t *params)
{
    // A,B are modified by ?GESV to carry LU info & X
    LAPACK(cgesv)(&params->N, &params->NRHS, params->A, &params->LDA,
                   params->IPIV, params->B, &params->LDB, &params->INFO);
}

/***************************************************************************
* Initialize the parameters to use in the lapack functions _gesv           *
* Handles buffer allocation
****************************************************************************/
static NPY_INLINE int
init_cgesv(GESV_PARAMS_t *params, npy_intp N_in, npy_intp NRHS_in, char trans)
{
    npy_uint8 *mem_buff = NULL;
    npy_uint8 *a, *b, *c;
    fortran_int N, NRHS, lda, ldb;
    size_t safe_N, safe_NRHS;

    N = (fortran_int)N_in;
    NRHS = (fortran_int)NRHS_in;
    lda = fortran_int_max(N, 1);
    ldb = fortran_int_max(N, 1);
    safe_N = N_in;
    safe_NRHS = NRHS_in;

    mem_buff = malloc(safe_N * safe_N * sizeof(fortran_complex)
                    + safe_N * safe_NRHS * sizeof(fortran_complex)
                    + safe_N * sizeof(fortran_int));
    if (!mem_buff) {
        goto error;
    }
    a = mem_buff;
    b = a + safe_N * safe_N * sizeof(fortran_complex);
    c = b + safe_N * safe_NRHS * sizeof(fortran_complex);

    params->A = a;
    params->B = b;
    params->IPIV = (fortran_int*)c;
    params->M = N;
    params->N = N;
    params->NRHS = NRHS;
    params->LDA = lda;
    params->LDB = ldb;
    params->INFO = 0;
    params->TRANS = trans;

    return 1;

  error:
    free(mem_buff);
    memset(params, 0, sizeof(*params));
    // PyErr_NoMemory();

    return 0;
}

// /************************
// * Deallocate buffer     *
// *************************/
//
// static NPY_INLINE void
// release_cgesv(GESV_PARAMS_t *params)
// {
//     /* 1st memory block base is in A */
//     free(params->A);
//     memset(params, 0, sizeof(*params));
// }


/************************
* Inner GUfunc loop     *
*************************/

// solve_signature = "(n,n),(n,nrhs)->(n,nrhs)";

static void
CFLOAT_solve(char **args, npy_intp *dimensions, npy_intp *steps,
            void *NPY_UNUSED(func))
{
    INIT_OUTER_LOOP_3
    npy_intp len_n = *dimensions++;  // rows
    npy_intp len_nrhs = *dimensions++;  // columns
    npy_intp stride_a_r = *steps++;  // rows
    npy_intp stride_a_c = *steps++;
    npy_intp stride_b_r = *steps++;  // rows
    npy_intp stride_b_c = *steps++;
    npy_intp stride_x_r = *steps++;  // rows
    npy_intp stride_x_c = *steps++;
    int error_occurred = get_fp_invalid_and_clear();
    GESV_PARAMS_t params;
    LINEARIZE_DATA_t a_in, b_in, x_out;

    if(init_cgesv(&params, len_n, len_nrhs, 'N')){
        init_linearize_data(&a_in, len_n, len_n, stride_a_c, stride_a_r);
        init_linearize_data(&b_in, len_nrhs, len_n, stride_b_c, stride_b_r);
        init_linearize_data(&x_out, len_nrhs, len_n, stride_x_c, stride_x_r);

        BEGIN_OUTER_LOOP
            int not_ok;
            linearize_CFLOAT_matrix(params.A, args[0], &a_in);
            linearize_CFLOAT_matrix(params.B, args[1], &b_in);
            call_cgesv(&params);
            not_ok = params.INFO;
            if (not_ok) {
                error_occurred = 1;
                nan_CFLOAT_matrix(args[2], &x_out);
            } else {
                delinearize_CFLOAT_matrix(args[2], params.B, &x_out);
            }
        END_OUTER_LOOP_3
        release_cgetrf(&params);
    }
    set_fp_invalid_or_clear(error_occurred);
}

/*************
* RSOLVE     *
**************/

// rsolve_signature = (nrhs,n),(n,n)->(nrhs,n)"

static void
CFLOAT_rsolve(char **args, npy_intp *dimensions, npy_intp *steps,
            void *NPY_UNUSED(func))
{
    /*swap (A,B) for (B^T,A^T)
    a,b here are not the same as A,B  in docstring: a=B^T, b=A^T */
    char *rargs[] = {args[1], args[0], args[2]};
    // dimensions = {N, len_nrhs, len_n};
    // rdimensions[] = {N, len_n, len_nrhs};
    npy_intp rdimensions[] = {dimensions[0], dimensions[2], dimensions[1]};
    // steps = {strides_b, strides_a, strides_x,
    //     strides_b_c, strides_b_r,
    //     strides_a_c, strides_a_r,
    //     strides_x_c, strides_x_r, };
    // rsteps = {strides_a, strides_b, strides_x,
    //     strides_a_r, strides_a_c,
    //     strides_b_r, strides_b_c,
    //     strides_x_r, strides_x_c, };
    npy_intp rsteps[] = {steps[1], steps[0], steps[2],
            steps[6], steps[5],
            steps[4], steps[3],
            steps[8], steps[7]};
    //now that we've swapped a,b and transposed, proceed as if we're in solve
    CFLOAT_solve(rargs, rdimensions, rsteps, NULL);
}

/***********************************************************
**                       SOLVE with LU                    **
************************************************************/

// solvelu_signature = "(n,n),(n,nrhs)->(n,nrhs),(n,n),(n)";
// rsolvelu_signature = "(nrhs,n),(n,n)->(nrhs,n),(n,n),(n)";
// lusolve_signature = "(n,n),(n),(n,nrhs)->(n,nrhs)";
// rlusolve_signature = "(nrhs,n),(n,n),(n)->(nrhs,n)";

/*******************************************
*   Calling BLAS/Lapack functions _getrs   *
********************************************/

static NPY_INLINE void
call_cgetrs(GESV_PARAMS_t *params)
{
    // B is modified by ?GETRS to carry X
    LAPACK(cgetrs)(&params->TRANS, &params->N, &params->NRHS,
                    params->A, &params->LDA, params->IPIV,
                    params->B, &params->LDB, &params->INFO);
}


/************************
* Inner GUfunc loop     *
*************************/

// solvelu_signature = "(n,n),(n,nrhs)->(n,nrhs),(n,n),(n)";

static void
CFLOAT_solvelu_loop(char **args, npy_intp *dimensions, npy_intp *steps, char trans)
{
    INIT_OUTER_LOOP_5
    npy_intp len_n = *dimensions++;  // rows
    npy_intp len_nrhs = *dimensions++;  // columns
    npy_intp stride_a_r = *steps++;  // rows, a
    npy_intp stride_a_c = *steps++;
    npy_intp stride_b_r = *steps++;  // rows, b
    npy_intp stride_b_c = *steps++;
    npy_intp stride_x_r = *steps++;  // rows, x = a\b
    npy_intp stride_x_c = *steps++;
    npy_intp stride_af_r = *steps++;  // rows, LU factors of a
    npy_intp stride_af_c = *steps++;
    npy_intp stride_ip = *steps++;  // vec, permutations, a = PLU
    int error_occurred = get_fp_invalid_and_clear();
    GESV_PARAMS_t params;
    LINEARIZE_DATA_t a_in, b_in, x_out, af_out, ipiv_out;

    if(init_cgesv(&params, len_n, len_nrhs, trans)){
        init_linearize_data(&a_in, len_n, len_n, stride_a_c, stride_a_r);
        init_linearize_data(&b_in, len_nrhs, len_n, stride_b_c, stride_b_r);
        init_linearize_data(&x_out, len_nrhs, len_n, stride_x_c, stride_x_r);
        init_linearize_data(&af_out, len_n, len_n, stride_af_c, stride_af_r);
        init_linearize_vdata(&ipiv_out, len_n, stride_ip);

        BEGIN_OUTER_LOOP_5
            int not_ok;
            linearize_CFLOAT_matrix(params.A, args[0], &a_in);
            linearize_CFLOAT_matrix(params.B, args[1], &b_in);
            call_cgetrf(&params);
            call_cgetrs(&params);
            not_ok = params.INFO;
            if (not_ok) {
                error_occurred = 1;
                nan_CFLOAT_matrix(args[2], &x_out);
                nan_CFLOAT_matrix(args[3], &af_out);
            } else {
                delinearize_CFLOAT_matrix(args[2], params.B, &x_out);
                delinearize_CFLOAT_matrix(args[3], params.A, &af_out);
                delinearize_INT_vec(args[4], params.IPIV, &ipiv_out);
            }
        END_OUTER_LOOP_5
        release_cgetrf(&params);
    }
    set_fp_invalid_or_clear(error_occurred);
}

// solvelu_signature = "(n,n),(n,nrhs)->(n,nrhs),(n,n),(n)";

static void
CFLOAT_solve_lu(char **args, npy_intp *dimensions, npy_intp *steps,
            void *NPY_UNUSED(func))
{
    CFLOAT_solvelu_loop(args, dimensions, steps, 'N');
}

/*************
* RSOLVELU   *
**************/

// rsolvelu_signature = "(nrhs,n),(n,n)->(nrhs,n),(n,n),(n)";

static void
CFLOAT_rsolve_lu(char **args, npy_intp *dimensions, npy_intp *steps,
            void *NPY_UNUSED(func))
{
    /*swap (A,B,X,Af,P) for (B^T,A,X^T,Af,P)
    a,b here are not the same as A,B  in docstring: a=B^T, b=A^T */
    char *rargs[] = {args[1], args[0], args[2], args[3], args[4]};
    // dimensions = {N, len_nrhs, len_n};
    // rdimensions[] = {N, len_n, len_nrhs};
    npy_intp rdimensions[] = {dimensions[0], dimensions[2], dimensions[1]};
    // steps = {strides_b, strides_a, strides_x, strides_af, strides_p,    0-4
    //     strides_b_c, strides_b_r,                5-6
    //     strides_a_r, strides_a_c,                7-8
    //     strides_x_c, strides_x_r,                9-10
    //     strides_af_r, strides_af_c, strides_ip}; 11-13
    // rsteps = {strides_a, strides_b, strides_x,
    //     strides_a_r, strides_a_c,
    //     strides_b_r, strides_b_c,
    //     strides_x_r, strides_x_c,
    //     strides_af_r, strides_af_c, strides_ip};
    npy_intp rsteps[] = {steps[1], steps[0], steps[2], steps[3], steps[4],
            steps[7], steps[8],
            steps[6], steps[5],
            steps[10], steps[9],
            steps[11], steps[12], steps[13]};
    //now that we've swapped a,b and transposed, proceed as if we're in solve
    CFLOAT_solvelu_loop(rargs, rdimensions, rsteps, 'T');
}

/*************
* LUSOLVE    *
**************/

// lusolve_signature = "(n,n),(n),(n,nrhs)->(n,nrhs)";

static void
CFLOAT_lusolve_loop(char **args, npy_intp *dimensions, npy_intp *steps, char trans)
{
    INIT_OUTER_LOOP_4
    npy_intp len_n = *dimensions++;  // rows
    npy_intp len_nrhs = *dimensions++;  // columns
    npy_intp stride_af_r = *steps++;  // rows, LU factors of a
    npy_intp stride_af_c = *steps++;
    npy_intp stride_ip = *steps++;  // vec, permutations, a = PLU
    npy_intp stride_b_r = *steps++;  // rows, b
    npy_intp stride_b_c = *steps++;
    npy_intp stride_x_r = *steps++;  // rows, x = a\b
    npy_intp stride_x_c = *steps++;
    int error_occurred = get_fp_invalid_and_clear();
    GESV_PARAMS_t params;
    LINEARIZE_DATA_t a_in, b_in, x_out, ipiv_in;

    if(init_cgesv(&params, len_n, len_nrhs, trans)){
        init_linearize_data(&a_in, len_n, len_n, stride_af_c, stride_af_r);
        init_linearize_vdata(&ipiv_in, len_n, stride_ip);
        init_linearize_data(&b_in, len_nrhs, len_n, stride_b_c, stride_b_r);
        init_linearize_data(&x_out, len_nrhs, len_n, stride_x_c, stride_x_r);

        BEGIN_OUTER_LOOP_4
            int not_ok;
            linearize_CFLOAT_matrix(params.A, args[0], &a_in);
            linearize_INT_vec(params.IPIV, args[1], &ipiv_in);
            linearize_CFLOAT_matrix(params.B, args[2], &b_in);
            call_cgetrs(&params);
            not_ok = params.INFO;
            if (not_ok) {
                error_occurred = 1;
                nan_CFLOAT_matrix(args[3], &x_out);
            } else {
                delinearize_CFLOAT_matrix(args[3], params.B, &x_out);
            }
        END_OUTER_LOOP_4
        release_cgetrf(&params);
    }
    set_fp_invalid_or_clear(error_occurred);
}

// lusolve_signature = "(n,n),(n),(n,nrhs)->(n,nrhs)";

static void
CFLOAT_lu_solve(char **args, npy_intp *dimensions, npy_intp *steps,
            void *NPY_UNUSED(func))
{
    CFLOAT_lusolve_loop(args, dimensions, steps, 'N');
}

/*************
* RLUSOLVE   *
**************/

// rlusolve_signature = "(nrhs,n),(n,n),(n)->(nrhs,n)";

static void
CFLOAT_rlu_solve(char **args, npy_intp *dimensions, npy_intp *steps,
            void *NPY_UNUSED(func))
{
    /*swap (A,P,B,X) for (B^T,A,P,X^T)
    a,b here are not the same as A,B  in docstring: a=B^T, b=A^T */
    char *rargs[] = {args[1], args[2], args[0], args[3]};
    // dimensions = {N, len_nrhs, len_n};
    // rdimensions[] = {N, len_n, len_nrhs};
    npy_intp rdimensions[] = {dimensions[0], dimensions[2], dimensions[1]};
    // steps = {strides_b, strides_a, strides_p, strides_x, 0-3
    //     strides_b_c, strides_b_r,                        4-5
    //     strides_a_r, strides_a_c, strides_ip             6-8
    //     strides_x_c, strides_x_r};                       9-10
    // rsteps = {strides_a, strides_p, strides_b, strides_x,
    //     strides_a_r, strides_a_c, strides_ip
    //     strides_b_r, strides_b_c,
    //     strides_x_r, strides_x_c};
    npy_intp rsteps[] = {steps[1], steps[2], steps[0], steps[3],
            steps[6], steps[7], steps[8],
            steps[5], steps[4],
            steps[10], steps[9]};
    //now that we've swapped a,b and transposed, proceed as if we're in solve
    CFLOAT_lusolve_loop(rargs, rdimensions, rsteps, 'T');
}


#line 263

// lu_signature = "(m,n)->(m,k),(k,n),(k)"
// lu_raw_signature = "(m,n)->(m,n),(k)"
/**************************************************
* Calling BLAS/Lapack function _getrf *
***************************************************/

static NPY_INLINE void
call_zgetrf(GESV_PARAMS_t *params)
{
    // A is modified by ?GETRF to carry LU info
    LAPACK(zgetrf)(&params->M, &params->N, params->A, &params->LDA,
                    params->IPIV, &params->INFO);
}

/***************************************************************************
* Initialize the parameters to use in the lapack functions _gesv           *
* Handles buffer allocation
****************************************************************************/
static NPY_INLINE int
init_zgetrf(GESV_PARAMS_t *params, npy_intp M_in, npy_intp N_in)
{
    npy_uint8 *mem_buff = NULL;
    npy_uint8 *a, *b;
    fortran_int M, N, K, lda;
    size_t safe_M, safe_N, safe_K;

    M = (fortran_int)M_in;
    N = (fortran_int)N_in;
    K = fortran_int_min(M, N);
    lda = fortran_int_max(M, 1);
    safe_N = M_in;
    safe_N = N_in;
    safe_K = K;

    mem_buff = malloc(safe_M * safe_N * sizeof(fortran_doublecomplex)
                    + safe_K * sizeof(fortran_int));
    if (!mem_buff) {
        goto error;
    }
    a = mem_buff;
    b = a + safe_M * safe_N * sizeof(fortran_doublecomplex);

    params->A = a;
    params->B = NULL;
    params->IPIV = (fortran_int*)b;
    params->M = M;
    params->N = N;
    params->NRHS = N;
    params->LDA = lda;
    params->LDB = 1;
    params->INFO = 0;
    params->TRANS = 'N';

    return 1;

  error:
    free(mem_buff);
    memset(params, 0, sizeof(*params));
    // PyErr_NoMemory();

    return 0;
}

/************************
* Deallocate buffer     *
*************************/

static NPY_INLINE void
release_zgetrf(GESV_PARAMS_t *params)
{
    /* 1st memory block base is in A */
    free(params->A);
    memset(params, 0, sizeof(*params));
}

/************************
* Inner GUfunc loop     *
*************************/

// lu_signature = "(m,n)->(m,k),(k,n),(k)"

static void
CDOUBLE_lu(char **args, npy_intp *dimensions, npy_intp *steps,
            void *NPY_UNUSED(func))
{
    INIT_OUTER_LOOP_4
    npy_intp len_m = *dimensions++;  // rows
    npy_intp len_n = *dimensions++;  // columns
    npy_intp stride_a_r = *steps++;  // rows
    npy_intp stride_a_c = *steps++;
    npy_intp stride_l_r = *steps++;  // rows
    npy_intp stride_l_c = *steps++;
    npy_intp stride_u_r = *steps++;  // rows
    npy_intp stride_u_c = *steps++;
    npy_intp stride_ip = *steps++;  // elements
    int error_occurred = get_fp_invalid_and_clear();
    GESV_PARAMS_t params;
    LINEARIZE_DATA_t a_in, l_out, u_out, ipiv_out;
    npy_intp len_k = npy_int_min(len_m, len_n);

    if(init_zgetrf(&params, len_m, len_n)) {
        init_linearize_data(&a_in, len_n, len_m, stride_a_c, stride_a_r);
        init_linearize_data(&l_out, len_k, len_m, stride_l_c, stride_l_r);
        init_linearize_data_ex(&u_out, len_n, len_k, stride_u_c, stride_u_r, len_m);
        init_linearize_vdata(&ipiv_out, len_k, stride_ip);

        BEGIN_OUTER_LOOP_4
            int not_ok;
            linearize_CDOUBLE_matrix(params.A, args[0], &a_in);
            call_zgetrf(&params);
            not_ok = params.INFO;
            if (not_ok) {
                error_occurred = 1;
                nan_CDOUBLE_matrix(args[1], &l_out);
                nan_CDOUBLE_matrix(args[2], &u_out);
            } else {
                zero_CDOUBLE_matrix(args[1], &l_out);
                eye_CDOUBLE_matrix(args[1], &l_out);
                delinearize_CDOUBLE_tril(args[1], params.A, &l_out);
                zero_CDOUBLE_matrix(args[2], &u_out);
                delinearize_CDOUBLE_triu(args[2], params.A, &u_out);
                delinearize_INT_vec(args[3], params.IPIV, &ipiv_out);
            }
        END_OUTER_LOOP_4
        release_zgetrf(&params);
    }
    set_fp_invalid_or_clear(error_occurred);
}

/************************
*         LU RAW        *
*************************/

// lu_raw_signature = "(m,n)->(m,n),(k)"

static void
CDOUBLE_lu_raw(char **args, npy_intp *dimensions, npy_intp *steps,
            void *NPY_UNUSED(func))
{
    INIT_OUTER_LOOP_3
    npy_intp len_m = *dimensions++;  // rows
    npy_intp len_n = *dimensions++;  // columns
    npy_intp stride_a_r = *steps++;  // rows
    npy_intp stride_a_c = *steps++;
    npy_intp stride_f_r = *steps++;  // rows
    npy_intp stride_f_c = *steps++;
    npy_intp stride_ip = *steps++;  // elements
    int error_occurred = get_fp_invalid_and_clear();
    GESV_PARAMS_t params;
    LINEARIZE_DATA_t a_in, f_out, ipiv_out;
    npy_intp len_k = npy_int_min(len_m, len_n);

    if(init_zgetrf(&params, len_m, len_n)) {
        init_linearize_data(&a_in, len_n, len_m, stride_a_c, stride_a_r);
        init_linearize_data(&f_out, len_n, len_m, stride_f_c, stride_f_r);
        init_linearize_vdata(&ipiv_out, len_k, stride_ip);

        BEGIN_OUTER_LOOP_3
            int not_ok;
            linearize_CDOUBLE_matrix(params.A, args[0], &a_in);
            call_zgetrf(&params);
            not_ok = params.INFO;
            if (not_ok) {
                error_occurred = 1;
                nan_CDOUBLE_matrix(args[1], &f_out);
            } else {
                delinearize_CDOUBLE_matrix(args[1], params.A, &f_out);
                delinearize_INT_vec(args[2], params.IPIV, &ipiv_out);
            }
        END_OUTER_LOOP_3
        release_zgetrf(&params);
    }
    set_fp_invalid_or_clear(error_occurred);
}

/*
******************************************************************************
**                                SOLVE                                     **
******************************************************************************
*/

// solve_signature = "(n,n),(n,nrhs)->(n,nrhs)";
// rsolve_signature = (nrhs,n),(n,n)->(nrhs,n)"

/******************************************
*   Calling BLAS/Lapack functions _gesv   *
*******************************************/

static NPY_INLINE void
call_zgesv(GESV_PARAMS_t *params)
{
    // A,B are modified by ?GESV to carry LU info & X
    LAPACK(zgesv)(&params->N, &params->NRHS, params->A, &params->LDA,
                   params->IPIV, params->B, &params->LDB, &params->INFO);
}

/***************************************************************************
* Initialize the parameters to use in the lapack functions _gesv           *
* Handles buffer allocation
****************************************************************************/
static NPY_INLINE int
init_zgesv(GESV_PARAMS_t *params, npy_intp N_in, npy_intp NRHS_in, char trans)
{
    npy_uint8 *mem_buff = NULL;
    npy_uint8 *a, *b, *c;
    fortran_int N, NRHS, lda, ldb;
    size_t safe_N, safe_NRHS;

    N = (fortran_int)N_in;
    NRHS = (fortran_int)NRHS_in;
    lda = fortran_int_max(N, 1);
    ldb = fortran_int_max(N, 1);
    safe_N = N_in;
    safe_NRHS = NRHS_in;

    mem_buff = malloc(safe_N * safe_N * sizeof(fortran_doublecomplex)
                    + safe_N * safe_NRHS * sizeof(fortran_doublecomplex)
                    + safe_N * sizeof(fortran_int));
    if (!mem_buff) {
        goto error;
    }
    a = mem_buff;
    b = a + safe_N * safe_N * sizeof(fortran_doublecomplex);
    c = b + safe_N * safe_NRHS * sizeof(fortran_doublecomplex);

    params->A = a;
    params->B = b;
    params->IPIV = (fortran_int*)c;
    params->M = N;
    params->N = N;
    params->NRHS = NRHS;
    params->LDA = lda;
    params->LDB = ldb;
    params->INFO = 0;
    params->TRANS = trans;

    return 1;

  error:
    free(mem_buff);
    memset(params, 0, sizeof(*params));
    // PyErr_NoMemory();

    return 0;
}

// /************************
// * Deallocate buffer     *
// *************************/
//
// static NPY_INLINE void
// release_zgesv(GESV_PARAMS_t *params)
// {
//     /* 1st memory block base is in A */
//     free(params->A);
//     memset(params, 0, sizeof(*params));
// }


/************************
* Inner GUfunc loop     *
*************************/

// solve_signature = "(n,n),(n,nrhs)->(n,nrhs)";

static void
CDOUBLE_solve(char **args, npy_intp *dimensions, npy_intp *steps,
            void *NPY_UNUSED(func))
{
    INIT_OUTER_LOOP_3
    npy_intp len_n = *dimensions++;  // rows
    npy_intp len_nrhs = *dimensions++;  // columns
    npy_intp stride_a_r = *steps++;  // rows
    npy_intp stride_a_c = *steps++;
    npy_intp stride_b_r = *steps++;  // rows
    npy_intp stride_b_c = *steps++;
    npy_intp stride_x_r = *steps++;  // rows
    npy_intp stride_x_c = *steps++;
    int error_occurred = get_fp_invalid_and_clear();
    GESV_PARAMS_t params;
    LINEARIZE_DATA_t a_in, b_in, x_out;

    if(init_zgesv(&params, len_n, len_nrhs, 'N')){
        init_linearize_data(&a_in, len_n, len_n, stride_a_c, stride_a_r);
        init_linearize_data(&b_in, len_nrhs, len_n, stride_b_c, stride_b_r);
        init_linearize_data(&x_out, len_nrhs, len_n, stride_x_c, stride_x_r);

        BEGIN_OUTER_LOOP
            int not_ok;
            linearize_CDOUBLE_matrix(params.A, args[0], &a_in);
            linearize_CDOUBLE_matrix(params.B, args[1], &b_in);
            call_zgesv(&params);
            not_ok = params.INFO;
            if (not_ok) {
                error_occurred = 1;
                nan_CDOUBLE_matrix(args[2], &x_out);
            } else {
                delinearize_CDOUBLE_matrix(args[2], params.B, &x_out);
            }
        END_OUTER_LOOP_3
        release_zgetrf(&params);
    }
    set_fp_invalid_or_clear(error_occurred);
}

/*************
* RSOLVE     *
**************/

// rsolve_signature = (nrhs,n),(n,n)->(nrhs,n)"

static void
CDOUBLE_rsolve(char **args, npy_intp *dimensions, npy_intp *steps,
            void *NPY_UNUSED(func))
{
    /*swap (A,B) for (B^T,A^T)
    a,b here are not the same as A,B  in docstring: a=B^T, b=A^T */
    char *rargs[] = {args[1], args[0], args[2]};
    // dimensions = {N, len_nrhs, len_n};
    // rdimensions[] = {N, len_n, len_nrhs};
    npy_intp rdimensions[] = {dimensions[0], dimensions[2], dimensions[1]};
    // steps = {strides_b, strides_a, strides_x,
    //     strides_b_c, strides_b_r,
    //     strides_a_c, strides_a_r,
    //     strides_x_c, strides_x_r, };
    // rsteps = {strides_a, strides_b, strides_x,
    //     strides_a_r, strides_a_c,
    //     strides_b_r, strides_b_c,
    //     strides_x_r, strides_x_c, };
    npy_intp rsteps[] = {steps[1], steps[0], steps[2],
            steps[6], steps[5],
            steps[4], steps[3],
            steps[8], steps[7]};
    //now that we've swapped a,b and transposed, proceed as if we're in solve
    CDOUBLE_solve(rargs, rdimensions, rsteps, NULL);
}

/***********************************************************
**                       SOLVE with LU                    **
************************************************************/

// solvelu_signature = "(n,n),(n,nrhs)->(n,nrhs),(n,n),(n)";
// rsolvelu_signature = "(nrhs,n),(n,n)->(nrhs,n),(n,n),(n)";
// lusolve_signature = "(n,n),(n),(n,nrhs)->(n,nrhs)";
// rlusolve_signature = "(nrhs,n),(n,n),(n)->(nrhs,n)";

/*******************************************
*   Calling BLAS/Lapack functions _getrs   *
********************************************/

static NPY_INLINE void
call_zgetrs(GESV_PARAMS_t *params)
{
    // B is modified by ?GETRS to carry X
    LAPACK(zgetrs)(&params->TRANS, &params->N, &params->NRHS,
                    params->A, &params->LDA, params->IPIV,
                    params->B, &params->LDB, &params->INFO);
}


/************************
* Inner GUfunc loop     *
*************************/

// solvelu_signature = "(n,n),(n,nrhs)->(n,nrhs),(n,n),(n)";

static void
CDOUBLE_solvelu_loop(char **args, npy_intp *dimensions, npy_intp *steps, char trans)
{
    INIT_OUTER_LOOP_5
    npy_intp len_n = *dimensions++;  // rows
    npy_intp len_nrhs = *dimensions++;  // columns
    npy_intp stride_a_r = *steps++;  // rows, a
    npy_intp stride_a_c = *steps++;
    npy_intp stride_b_r = *steps++;  // rows, b
    npy_intp stride_b_c = *steps++;
    npy_intp stride_x_r = *steps++;  // rows, x = a\b
    npy_intp stride_x_c = *steps++;
    npy_intp stride_af_r = *steps++;  // rows, LU factors of a
    npy_intp stride_af_c = *steps++;
    npy_intp stride_ip = *steps++;  // vec, permutations, a = PLU
    int error_occurred = get_fp_invalid_and_clear();
    GESV_PARAMS_t params;
    LINEARIZE_DATA_t a_in, b_in, x_out, af_out, ipiv_out;

    if(init_zgesv(&params, len_n, len_nrhs, trans)){
        init_linearize_data(&a_in, len_n, len_n, stride_a_c, stride_a_r);
        init_linearize_data(&b_in, len_nrhs, len_n, stride_b_c, stride_b_r);
        init_linearize_data(&x_out, len_nrhs, len_n, stride_x_c, stride_x_r);
        init_linearize_data(&af_out, len_n, len_n, stride_af_c, stride_af_r);
        init_linearize_vdata(&ipiv_out, len_n, stride_ip);

        BEGIN_OUTER_LOOP_5
            int not_ok;
            linearize_CDOUBLE_matrix(params.A, args[0], &a_in);
            linearize_CDOUBLE_matrix(params.B, args[1], &b_in);
            call_zgetrf(&params);
            call_zgetrs(&params);
            not_ok = params.INFO;
            if (not_ok) {
                error_occurred = 1;
                nan_CDOUBLE_matrix(args[2], &x_out);
                nan_CDOUBLE_matrix(args[3], &af_out);
            } else {
                delinearize_CDOUBLE_matrix(args[2], params.B, &x_out);
                delinearize_CDOUBLE_matrix(args[3], params.A, &af_out);
                delinearize_INT_vec(args[4], params.IPIV, &ipiv_out);
            }
        END_OUTER_LOOP_5
        release_zgetrf(&params);
    }
    set_fp_invalid_or_clear(error_occurred);
}

// solvelu_signature = "(n,n),(n,nrhs)->(n,nrhs),(n,n),(n)";

static void
CDOUBLE_solve_lu(char **args, npy_intp *dimensions, npy_intp *steps,
            void *NPY_UNUSED(func))
{
    CDOUBLE_solvelu_loop(args, dimensions, steps, 'N');
}

/*************
* RSOLVELU   *
**************/

// rsolvelu_signature = "(nrhs,n),(n,n)->(nrhs,n),(n,n),(n)";

static void
CDOUBLE_rsolve_lu(char **args, npy_intp *dimensions, npy_intp *steps,
            void *NPY_UNUSED(func))
{
    /*swap (A,B,X,Af,P) for (B^T,A,X^T,Af,P)
    a,b here are not the same as A,B  in docstring: a=B^T, b=A^T */
    char *rargs[] = {args[1], args[0], args[2], args[3], args[4]};
    // dimensions = {N, len_nrhs, len_n};
    // rdimensions[] = {N, len_n, len_nrhs};
    npy_intp rdimensions[] = {dimensions[0], dimensions[2], dimensions[1]};
    // steps = {strides_b, strides_a, strides_x, strides_af, strides_p,    0-4
    //     strides_b_c, strides_b_r,                5-6
    //     strides_a_r, strides_a_c,                7-8
    //     strides_x_c, strides_x_r,                9-10
    //     strides_af_r, strides_af_c, strides_ip}; 11-13
    // rsteps = {strides_a, strides_b, strides_x,
    //     strides_a_r, strides_a_c,
    //     strides_b_r, strides_b_c,
    //     strides_x_r, strides_x_c,
    //     strides_af_r, strides_af_c, strides_ip};
    npy_intp rsteps[] = {steps[1], steps[0], steps[2], steps[3], steps[4],
            steps[7], steps[8],
            steps[6], steps[5],
            steps[10], steps[9],
            steps[11], steps[12], steps[13]};
    //now that we've swapped a,b and transposed, proceed as if we're in solve
    CDOUBLE_solvelu_loop(rargs, rdimensions, rsteps, 'T');
}

/*************
* LUSOLVE    *
**************/

// lusolve_signature = "(n,n),(n),(n,nrhs)->(n,nrhs)";

static void
CDOUBLE_lusolve_loop(char **args, npy_intp *dimensions, npy_intp *steps, char trans)
{
    INIT_OUTER_LOOP_4
    npy_intp len_n = *dimensions++;  // rows
    npy_intp len_nrhs = *dimensions++;  // columns
    npy_intp stride_af_r = *steps++;  // rows, LU factors of a
    npy_intp stride_af_c = *steps++;
    npy_intp stride_ip = *steps++;  // vec, permutations, a = PLU
    npy_intp stride_b_r = *steps++;  // rows, b
    npy_intp stride_b_c = *steps++;
    npy_intp stride_x_r = *steps++;  // rows, x = a\b
    npy_intp stride_x_c = *steps++;
    int error_occurred = get_fp_invalid_and_clear();
    GESV_PARAMS_t params;
    LINEARIZE_DATA_t a_in, b_in, x_out, ipiv_in;

    if(init_zgesv(&params, len_n, len_nrhs, trans)){
        init_linearize_data(&a_in, len_n, len_n, stride_af_c, stride_af_r);
        init_linearize_vdata(&ipiv_in, len_n, stride_ip);
        init_linearize_data(&b_in, len_nrhs, len_n, stride_b_c, stride_b_r);
        init_linearize_data(&x_out, len_nrhs, len_n, stride_x_c, stride_x_r);

        BEGIN_OUTER_LOOP_4
            int not_ok;
            linearize_CDOUBLE_matrix(params.A, args[0], &a_in);
            linearize_INT_vec(params.IPIV, args[1], &ipiv_in);
            linearize_CDOUBLE_matrix(params.B, args[2], &b_in);
            call_zgetrs(&params);
            not_ok = params.INFO;
            if (not_ok) {
                error_occurred = 1;
                nan_CDOUBLE_matrix(args[3], &x_out);
            } else {
                delinearize_CDOUBLE_matrix(args[3], params.B, &x_out);
            }
        END_OUTER_LOOP_4
        release_zgetrf(&params);
    }
    set_fp_invalid_or_clear(error_occurred);
}

// lusolve_signature = "(n,n),(n),(n,nrhs)->(n,nrhs)";

static void
CDOUBLE_lu_solve(char **args, npy_intp *dimensions, npy_intp *steps,
            void *NPY_UNUSED(func))
{
    CDOUBLE_lusolve_loop(args, dimensions, steps, 'N');
}

/*************
* RLUSOLVE   *
**************/

// rlusolve_signature = "(nrhs,n),(n,n),(n)->(nrhs,n)";

static void
CDOUBLE_rlu_solve(char **args, npy_intp *dimensions, npy_intp *steps,
            void *NPY_UNUSED(func))
{
    /*swap (A,P,B,X) for (B^T,A,P,X^T)
    a,b here are not the same as A,B  in docstring: a=B^T, b=A^T */
    char *rargs[] = {args[1], args[2], args[0], args[3]};
    // dimensions = {N, len_nrhs, len_n};
    // rdimensions[] = {N, len_n, len_nrhs};
    npy_intp rdimensions[] = {dimensions[0], dimensions[2], dimensions[1]};
    // steps = {strides_b, strides_a, strides_p, strides_x, 0-3
    //     strides_b_c, strides_b_r,                        4-5
    //     strides_a_r, strides_a_c, strides_ip             6-8
    //     strides_x_c, strides_x_r};                       9-10
    // rsteps = {strides_a, strides_p, strides_b, strides_x,
    //     strides_a_r, strides_a_c, strides_ip
    //     strides_b_r, strides_b_c,
    //     strides_x_r, strides_x_c};
    npy_intp rsteps[] = {steps[1], steps[2], steps[0], steps[3],
            steps[6], steps[7], steps[8],
            steps[5], steps[4],
            steps[10], steps[9]};
    //now that we've swapped a,b and transposed, proceed as if we're in solve
    CDOUBLE_lusolve_loop(rargs, rdimensions, rsteps, 'T');
}



/*
*****************************************************************************
**                             Ufunc definition                            **
*****************************************************************************
*/


GUFUNC_FUNC_ARRAY_REAL_COMPLEX(solve);
GUFUNC_FUNC_ARRAY_REAL_COMPLEX(rsolve);
GUFUNC_FUNC_ARRAY_REAL_COMPLEX(solve_lu);
GUFUNC_FUNC_ARRAY_REAL_COMPLEX(rsolve_lu);
GUFUNC_FUNC_ARRAY_REAL_COMPLEX(lu_solve);
GUFUNC_FUNC_ARRAY_REAL_COMPLEX(rlu_solve);
GUFUNC_FUNC_ARRAY_REAL_COMPLEX(lu);
GUFUNC_FUNC_ARRAY_REAL_COMPLEX(lu_raw);

static char ufn_types_solve_4[] = { NPY_FLOAT, NPY_INT, NPY_FLOAT, NPY_FLOAT,
                                NPY_DOUBLE, NPY_INT, NPY_DOUBLE, NPY_DOUBLE,
                                NPY_CFLOAT, NPY_INT, NPY_CFLOAT, NPY_CFLOAT,
                                NPY_CDOUBLE, NPY_INT, NPY_CDOUBLE, NPY_CDOUBLE };
static char ufn_types_rsolve_4[] = { NPY_FLOAT, NPY_FLOAT, NPY_INT, NPY_FLOAT,
                                NPY_DOUBLE, NPY_DOUBLE, NPY_INT, NPY_DOUBLE,
                                NPY_CFLOAT, NPY_CFLOAT, NPY_INT, NPY_CFLOAT,
                                NPY_CDOUBLE, NPY_CDOUBLE, NPY_INT, NPY_CDOUBLE };
static char ufn_types_lu_3[] = { NPY_FLOAT, NPY_FLOAT, NPY_INT,
                                NPY_DOUBLE, NPY_DOUBLE, NPY_INT,
                                NPY_CFLOAT, NPY_CFLOAT, NPY_INT,
                                NPY_CDOUBLE, NPY_CDOUBLE, NPY_INT };
static char ufn_types_lu_4[] = { NPY_FLOAT, NPY_FLOAT, NPY_FLOAT, NPY_INT,
                                NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE, NPY_INT,
                                NPY_CFLOAT, NPY_CFLOAT, NPY_CFLOAT, NPY_INT,
                                NPY_CDOUBLE, NPY_CDOUBLE, NPY_CDOUBLE, NPY_INT };
static char ufn_types_lu_5[] = { NPY_FLOAT, NPY_FLOAT, NPY_FLOAT, NPY_FLOAT, NPY_INT,
                                NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE, NPY_INT,
                                NPY_CFLOAT, NPY_CFLOAT, NPY_CFLOAT, NPY_CFLOAT, NPY_INT,
                                NPY_CDOUBLE, NPY_CDOUBLE, NPY_CDOUBLE, NPY_CDOUBLE, NPY_INT };

GUFUNC_DESCRIPTOR_t gufunc_descriptors[] = {
    { "solve", "(n,n),(n,nrhs)->(n,nrhs)", solve__doc__, 4, 2, 1,
        FUNC_ARRAY_NAME(solve), ufn_types_4_3 },
    { "rsolve", "(nrhs,n),(n,n)->(nrhs,n)", rsolve__doc__, 4, 2, 1,
        FUNC_ARRAY_NAME(rsolve), ufn_types_4_3 },
    { "solve_lu", "(n,n),(n,nrhs)->(n,nrhs),(n,n),(n)", solve_lu__doc__, 4, 2, 3,
        FUNC_ARRAY_NAME(solve_lu), ufn_types_lu_5 },
    { "rsolve_lu", "(nrhs,n),(n,n)->(nrhs,n),(n,n),(n)", rsolve_lu__doc__, 4, 2, 3,
        FUNC_ARRAY_NAME(rsolve_lu), ufn_types_lu_5 },
    { "lu_solve", "(n,n),(n),(n,nrhs)->(n,nrhs)", lu_solve__doc__, 4, 3, 1,
        FUNC_ARRAY_NAME(lu_solve), ufn_types_solve_4 },
    { "rlu_solve", "(nrhs,n),(n,n),(n)->(nrhs,n)", rlu_solve__doc__, 4, 3, 1,
        FUNC_ARRAY_NAME(rlu_solve), ufn_types_rsolve_4 },
    { "lu_m", "(m,n)->(m,m),(m,n),(m)", lu__doc__, 4, 1, 3,
        FUNC_ARRAY_NAME(lu), ufn_types_lu_4 },
    { "lu_n", "(m,n)->(m,n),(n,n),(n)", lu__doc__, 4, 1, 3,
        FUNC_ARRAY_NAME(lu), ufn_types_lu_4 },
    { "lu_rawm", "(m,n)->(m,n),(m)", lu_raw__doc__, 4, 1, 2,
        FUNC_ARRAY_NAME(lu_raw), ufn_types_lu_3 },
    { "lu_rawn", "(m,n)->(m,n),(n)", lu_raw__doc__, 4, 1, 2,
        FUNC_ARRAY_NAME(lu_raw), ufn_types_lu_3 }
};

/*
*****************************************************************************
**               Module initialization stuff                               **
*****************************************************************************
*/

static PyMethodDef GUfuncs_LUSOLVE_Methods[] = {
    {NULL, NULL, 0, NULL}        /* Sentinel */
};

static struct PyModuleDef moduledef = {
    PyModuleDef_HEAD_INIT,
    "_gufuncs_lu_solve",
    NULL,
    -1,
    GUfuncs_LUSOLVE_Methods,
    NULL,
    NULL,
    NULL,
    NULL
};

PyObject *PyInit__gufuncs_lu_solve(void)
{
    PyObject *m;

    init_constants();
    m = PyModule_Create(&moduledef);
    if (m == NULL) {
        return NULL;
    }

    import_array();
    import_ufunc();

    /* Load the ufunc operators into the module's namespace */
    int failure = addUfuncs(m, gufunc_descriptors, 10, gufuncs_lu_solve_version_string);

    if (PyErr_Occurred() || failure) {
        PyErr_SetString(PyExc_RuntimeError,
                        "cannot load _gufuncs_lu_solve module.");
        return NULL;
    }

    return m;
}

