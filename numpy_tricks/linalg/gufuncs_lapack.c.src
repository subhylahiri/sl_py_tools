/* More complicated GUFuncs with Lapack
*/
/*
Adapted from https://github.com/numpy/numpy/numpy/linalg/umath_linalg.c.src
Copyright/licence info for that file:
* Copyright (c) 2005-2017, NumPy Developers.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
*   - Redistributions of source code must retain the above
*     copyright notice, this list of conditions and the
*     following disclaimer.
*   - Redistributions in binary form must reproduce the above copyright
*     notice, this list of conditions and the following disclaimer
*     in the documentation and/or other materials provided with the
*     distribution.
*   - Neither the name of the author nor the names of its
*     contributors may be used to endorse or promote products derived
*     from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
* A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*              Table of Contents
50.   Includes
61.   Docstrings
172.  BLAS/Lapack calling functions
232.  Data rearrangement functions
503.  QR
933.  SOLVE
1110. LSTSQ
1439. Ufunc definition
1480. Module initialization stuff
*/

/*
*****************************************************************************
**                            Includes                                     **
*****************************************************************************
*/
#define NPY_NO_DEPRECATED_API NPY_API_VERSION

#include "gufunc_common_f.h"

static const char* gufuncs_lapack_version_string = "0.1.0";

/*
*****************************************************************************
**                   Doc string for Python functions                       **
*****************************************************************************
*/

PyDoc_STRVAR(qr__doc__,
//"qr(A: ndarray) -> (Q: ndarray, R: ndarray)\n\n"
"QR decomposition.\n\n"
"Factor a matrix as `A = QR` with `Q` orthogonal and `R` upper-triangular.\n"
"`K` = `M` or `N`, depending on which of `qr_m` or `qr_n` was called. \n"
"When M < N, `qr_n` cannot be called.\n\n"
"Parameters\n-----------\n"
"A: ndarray (...,M,N)\n"
"    Matrix to be factored.\n\n"
"Returns\n-------\n"
"Q: ndarray (...,M,K)\n"
"    Matrix with orthonormal columns.\n"
"R: ndarray (...,K,N)\n"
"    Matrix with zeros below the diagonal.");

PyDoc_STRVAR(qrr__doc__,
//qr(A: ndarray) -> (R: ndarray)\n\n"
"QR decomposition.\n\n"
"Factor a matrix as `A = QR` with `Q` orthogonal and `R` upper-triangular. \n"
"This version only returns `R`. \n"
"`K` = `M` or `N`, depending on which of `qr_rm` or `qr_rn` was called. \n"
"When M < N, `qr_rn` cannot be called.\n\n"
"Parameters\n-----------\n"
"A: ndarray (...,M,N)\n"
"    Matrix to be factored.\n\n"
"Returns\n-------\n"
"R: ndarray (...,K,N)\n"
"    Matrix with zeros below the diagonal.");

PyDoc_STRVAR(qrraw__doc__,
//"qr_raw(A: ndarray) -> (H: ndarray, tau: ndarray)\n\n"
"QR decomposition.\n\n"
"Factor a matrix as `A = QR` with `Q` orthogonal and `R` upper-triangular. \n"
"This version returns `R`, the Householder reflectors, `v`, \n"
"and their scaling factors, `tau`. \n"
"`K` = `M` or `N`, depending on which of `qr_rawm` or `qr_rawn` was called. \n"
"When M < N, `qr_rawn` cannot be called.\n\n"
"Parameters\n-----------\n"
"A: ndarray (...,M,N)\n"
"    Matrix to be factored.\n\n"
"Returns\n-------\n"
"H: ndarray (...,N,M)\n"
"    Transpose of matrix for use in Fortran. Above and on the diagonal: `R`.\n"
"    Below the diagonal: the Householder reflectors `v`.\n"
"tau: ndarray (...,K,)\n"
"    Scaling factors for Householder reflectors.");

PyDoc_STRVAR(solve__doc__,
//"solve(A: ndarray, B: ndarray) -> (C: ndarray)\n\n"
"Solve linear system.\n\n"
"Solve the equation `AX = B` for `X`.\n\n"
"Parameters\n-----------\n"
"A: ndarray (...,N,N)\n"
"    Matrix of coefficients.\n"
"B: ndarray (...,N,NRHS)\n"
"    Matrix of result vectors.\n\n"
"Returns\n-------\n"
"X: ndarray (...,N,NRHS)\n"
"    Matrix of solution vectors.\n");

PyDoc_STRVAR(rsolve__doc__,
//"solve(A: ndarray, B: ndarray) -> (C: ndarray)\n\n"
"Solve reversed linear system.\n\n"
"Solve the equation `A = XB` for `X`.\n\n"
"Parameters\n-----------\n"
"A: ndarray (...,NRHS,N)\n"
"    Matrix of coefficients.\n"
"B: ndarray (...,N,N)\n"
"    Matrix of result vectors.\n\n"
"Returns\n-------\n"
"X: ndarray (...,NRHS,N)\n"
"    Matrix of solution vectors.\n");

PyDoc_STRVAR(lstsq__doc__,
//"lstsq(A: ndarray, B: ndarray) -> (C: ndarray)\n\n"
"Least-square solution of linear system.\n\n"
"Find the least-square solution of the equation `AX = B` for `X`. \n"
"Unlike `numpy.linalg.lstsq`, this version does not return `residuals`, \n"
"rank or singuar values, and uses the default value for `rcond`. \n"
"It is intended for use in binary operators.\n\n"
"Parameters\n-----------\n"
"A: ndarray (...,M,N)\n"
"    Matrix of coefficients.\n"
"B: ndarray (...,M,NRHS)\n"
"    Matrix of result vectors.\n\n"
"Returns\n-------\n"
"X: ndarray (...,N,NRHS)\n"
"    Matrix of solution vectors.\n");

PyDoc_STRVAR(rlstsq__doc__,
//"lstsq(A: ndarray, B: ndarray) -> (C: ndarray)\n\n"
"Least-square solution of reversed linear system.\n\n"
"Find the least-square solution of the equation `A = XB` for `X`. \n"
"Unlike `numpy.linalg.lstsq`, this version does not return `residuals`, \n"
"rank or singuar values, and uses the default value for `rcond`. \n"
"It is intended for use in binary operators.\n\n"
"Parameters\n-----------\n"
"A: ndarray (...,NRHS,M)\n"
"    Matrix of coefficients.\n"
"B: ndarray (...,N,M)\n"
"    Matrix of result vectors.\n\n"
"Returns\n-------\n"
"X: ndarray (...,NRHS,N)\n"
"    Matrix of solution vectors.\n");

/*
*****************************************************************************
**                   BLAS/Lapack calling macros                            **
*****************************************************************************
*/
/**begin repeat
    #typ = float, double, f2c_complex, f2c_doublecomplex#
    #copy = scopy, dcopy, ccopy, zcopy#
    #geqrf = sgeqrf, dgeqrf, cgeqrf, zgeqrf#
    #orgqr = sorgqr, dorgqr, cungqr, zungqr#
    #gesv = sgesv, dgesv, cgesv, zgesv#
*/

/* copy vector x into y */
extern int
FNAME(@copy@)(int *n,
            @typ@ *sx, int *incx,
            @typ@ *sy, int *incy);

/* qr decomposition of a */
/* a -> r, v, tau */
extern int
FNAME(@geqrf@)(int *m, int *n, @typ@ *a, int *lda, @typ@ *tau,
            @typ@ *work, int * lwork, int *info);
/* v, tau -> q */
extern int
FNAME(@orgqr@)(int *m, int *n, int *k,
            @typ@ *a, int *lda, @typ@ *tau,
            @typ@ *work, int * lwork, int *info);

/* solve a x = b for x */
extern int
FNAME(@gesv@)(int *n, int *nrhs,
            @typ@ *a, int *lda, int * ipiv,
            @typ@ *b, int *ldb, int *info);

/**end repeat**/

/**begin repeat
    #typ = f2c_complex, f2c_doublecomplex#
    #rtyp = float, double#
    #gelsd = sgelsd, dgelsd#
    #gclsd = cgelsd, zgelsd#
*/

/* least square solution of a x = b for x */
extern int
FNAME(@gelsd@)(int *m, int *n, int *nrhs,
            @rtyp@ *a, int *lda, @rtyp@ *b, int *ldb,
            @rtyp@ *s, @rtyp@ *rcond, int *rank,
            @rtyp@ *work, int *lwork, int *iwork, int *info);

extern int
FNAME(@gclsd@)(int *m, int *n, int *nrhs,
            @typ@ *a, int *lda, @typ@ *b, int *ldb,
            @rtyp@ *s, @rtyp@ *rcond, int *rank, @typ@ *work,
            int *lwork, @rtyp@ *rwork, int *iwork, int *info);

/**end repeat**/

/*
*****************************************************************************
**                    Data rearrangement functions                         **
*****************************************************************************
*/

              /* rearranging of 2D matrices using blas */

/**begin repeat
    #TYPE = FLOAT, DOUBLE, CFLOAT, CDOUBLE#
    #typ = float, double, COMPLEX_t, DOUBLECOMPLEX_t#
    #copy = scopy, dcopy, ccopy, zcopy#
    #zero = s_zero, d_zero, c_zero, z_zero#
    #nan = s_nan, d_nan, c_nan, z_nan#
*/

static NPY_INLINE void *
linearize_@TYPE@_matrix(void *dst_in,
                         const void *src_in,
                         const LINEARIZE_DATA_t* data)
{
    @typ@ *src = (@typ@ *) src_in;
    @typ@ *dst = (@typ@ *) dst_in;

    if (dst) {
        int i, j;
        @typ@* rv = dst;
        fortran_int columns = (fortran_int)data->columns;
        fortran_int column_strides =
                (fortran_int)(data->column_strides/sizeof(@typ@));
        fortran_int one = 1;
        for (i = 0; i < data->rows; i++) {
            if (column_strides > 0) {
                FNAME(@copy@)(&columns,
                              (void*)src, &column_strides,
                              (void*)dst, &one);
            }
            else if (column_strides < 0) {
                FNAME(@copy@)(&columns,
                              (void*)((@typ@*)src + (columns-1)*column_strides),
                              &column_strides,
                              (void*)dst, &one);
            }
            else {
            /*
             * Zero stride has undefined behavior in some BLAS
             * implementations (e.g. OSX Accelerate), so do it
             * manually
             */
            for (j = 0; j < columns; ++j) {
                memcpy((@typ@*)dst + j, (@typ@*)src, sizeof(@typ@));
            }
            }
            src += data->row_strides/sizeof(@typ@);
            dst += data->output_lead_dim;
        }
        return rv;
    } else {
        return src;
    }
}

static NPY_INLINE void *
delinearize_@TYPE@_matrix(void *dst_in,
                        const void *src_in,
                        const LINEARIZE_DATA_t* data)
{
    @typ@ *src = (@typ@ *) src_in;
    @typ@ *dst = (@typ@ *) dst_in;

    if (src) {
        int i;
        @typ@ *rv = src;
        fortran_int columns = (fortran_int)data->columns;
        fortran_int column_strides =
          (fortran_int)(data->column_strides/sizeof(@typ@));
        fortran_int one = 1;
        for (i = 0; i < data->rows; i++) {
            if (column_strides > 0) {
                FNAME(@copy@)(&columns,
                              (void*)src, &one,
                              (void*)dst, &column_strides);
            }
            else if (column_strides < 0) {
                FNAME(@copy@)(&columns,
                              (void*)src, &one,
                              (void*)((@typ@*)dst + (columns-1)*column_strides),
                              &column_strides);
            }
            else {
              /*
               * Zero stride has undefined behavior in some BLAS
               * implementations (e.g. OSX Accelerate), so do it
               * manually
               */
                if (columns > 0) {
                    memcpy((@typ@*)dst,
                           (@typ@*)src + (columns-1),
                           sizeof(@typ@));
              }
            }
            src += data->output_lead_dim;
            dst += data->row_strides/sizeof(@typ@);
        }
        return rv;
    } else {
        return src;
    }
}

static NPY_INLINE void *
delinearize_@TYPE@_triu(void *dst_in,
                        const void *src_in,
                        const LINEARIZE_DATA_t* data)
{
   @typ@ *src = (@typ@ *) src_in;
   @typ@ *dst = (@typ@ *) dst_in;

   if (src) {
       int i;
        @typ@ *rv = src;
        fortran_int columns = (fortran_int)data->columns;
        fortran_int column_strides =
            (fortran_int)(data->column_strides/sizeof(@typ@));
        fortran_int one = 1;
        for (i = 0; i < data->rows; i++) {
            fortran_int n = fortran_int_min(i + one, columns);
            if (column_strides > 0) {
                FNAME(@copy@)(&n,
                              (void*)src, &one,
                              (void*)dst, &column_strides);
            }
            else if (column_strides < 0) {
                FNAME(@copy@)(&n,
                              (void*)src, &one,
                              (void*)((@typ@*)dst + (n-1)*column_strides),
                              &column_strides);
            }
            else {
               /*
                * Zero stride has undefined behavior in some BLAS
                * implementations (e.g. OSX Accelerate), so do it
                * manually
                */
                if (columns > 0) {
                    memcpy((@typ@*)dst,
                           (@typ@*)src + (columns-1),
                           sizeof(@typ@));
                }
            }
            src += data->output_lead_dim;
            dst += data->row_strides/sizeof(@typ@);
        }

        return rv;
    } else {
        return src;
    }
}

static NPY_INLINE void
nan_@TYPE@_matrix(void *dst_in, const LINEARIZE_DATA_t* data)
{
    @typ@ *dst = (@typ@ *) dst_in;

    int i, j;
    ptrdiff_t cs = data->column_strides/sizeof(@typ@);
    for (i = 0; i < data->rows; i++) {
        @typ@ *cp = dst;
        for (j = 0; j < data->columns; ++j) {
            *cp = @nan@;
            cp += cs;
        }
        dst += data->row_strides/sizeof(@typ@);
    }
}

static NPY_INLINE void
zero_@TYPE@_matrix(void *dst_in, const LINEARIZE_DATA_t* data)
{
    @typ@ *dst = (@typ@ *) dst_in;

    int i, j;
    ptrdiff_t cs = data->column_strides/sizeof(@typ@);
    for (i = 0; i < data->rows; i++) {
        @typ@ *cp = dst;
        for (j = 0; j < data->columns; ++j) {
            *cp = @zero@;
            cp += cs;
        }
        dst += data->row_strides/sizeof(@typ@);
    }
}

static NPY_INLINE void *
delinearize_@TYPE@_vec(void *dst_in,
                     void *src_in,
                     const LINEARIZE_VDATA_t *data)
{
    @typ@ *src = (@typ@ *) src_in;
    @typ@ *dst = (@typ@ *) dst_in;

    if (dst) {
        @typ@* rv = dst;
        fortran_int len = (fortran_int)data->len;
        fortran_int strides = (fortran_int)(data->strides/sizeof(@typ@));
        fortran_int one = 1;
        if (strides > 0) {
            FNAME(@copy@)(&len,
                          (void*)src, &one,
                          (void*)dst, &strides);
        }
        else if (strides < 0) {
            FNAME(@copy@)(&len,
                          (void*)((@typ@*)src + (len-1)*strides),
                          &one,
                          (void*)dst, &strides);
        }
        else {
            /*
             * Zero stride has undefined behavior in some BLAS
             * implementations (e.g. OSX Accelerate), so do it
             * manually
             */
            int j;
            for (j = 0; j < len; ++j) {
                memcpy((@typ@*)dst, (@typ@*)src + j, sizeof(@typ@));
            }
        }
        return rv;
    } else {
        return src;
    }
}

static NPY_INLINE void
nan_@TYPE@_vec(void *dst_in, const LINEARIZE_VDATA_t* data)
{
    @typ@ *dst = (@typ@ *) dst_in;

    int j;
    ptrdiff_t cs = data->strides/sizeof(@typ@);
    for (j = 0; j < data->len; ++j) {
        *dst = @nan@;
        dst += cs;
    }
}

/**end repeat**/

/**begin repeat
    #TYPE = FLOAT, DOUBLE#
    #ftyp = fortran_real, fortran_doublereal#
*/
static fortran_int
@TYPE@_to_int(@ftyp@ x)
{
    return (fortran_int)x;
}
/**end repeat**/
/**begin repeat
    #TYPE = CFLOAT, CDOUBLE#
    #ftyp = fortran_complex, fortran_doublecomplex#
*/
static fortran_int
@TYPE@_to_int(@ftyp@ x)
{
    return (fortran_int)x.r;
}
/**end repeat**/

/*
*****************************************************************************
**                         QR DECOMPOSITION                                **
*****************************************************************************
*/

// char *qr_m_signature = "(m,n)->(m,m),(m,n)";  // m<n
// char *qr_n_signature = "(m,n)->(m,n),(n,n)";  // m>n

typedef struct geqrf_params_struct
{
    void *A; /* A is (M,N) of base type */
    void *T; /* X is (K,) of base type */
    void *WR; /* WR is (N*B,) of base type, work for _geqrf */
    void *WQ; /* WQ is (N*B,) of base type, work for _orgqr */

    fortran_int M;
    fortran_int N;
    fortran_int K;
    fortran_int NC;
    fortran_int LDA;
    fortran_int LWR; /* LWR is lwork for _geqrf */
    fortran_int LWQ; /* LWQ is lwork for _orgqr */
    fortran_int INFO;
} GEQRF_PARAMS_t;

/**begin repeat
    #TYPE = FLOAT, DOUBLE, CFLOAT, CDOUBLE#
    #typ = npy_float, npy_double, npy_cfloat, npy_cdouble#
    #ftyp = fortran_real, fortran_doublereal, fortran_complex, fortran_doublecomplex#
    #geqrf = sgeqrf, dgeqrf, cgeqrf, zgeqrf#
    #orgqr = sorgqr, dorgqr, cungqr, zungqr#
*/

/* ************************************************
* Calling BLAS/Lapack functions _geqrf and _orgqr *
*************************************************** */

static NPY_INLINE void
call_@geqrf@(GEQRF_PARAMS_t *params)
{
    // A,T are modified by ?GEQRF to carry QR info
    LAPACK(@geqrf@)(&params->M, &params->N, params->A, &params->LDA,
                    params->T, params->WR, &params->LWR, &params->INFO);
}

static NPY_INLINE void
call_@orgqr@(GEQRF_PARAMS_t *params)
{
    // A is modified by ?ORGQR to carry Q
    LAPACK(@orgqr@)(&params->M, &params->NC, &params->K, params->A, &params->LDA,
                    params->T, params->WQ, &params->LWQ, &params->INFO);
}

/* *************************************************************************
* Initialize the parameters to use in the lapack functions _geqrf &  _orgqr*
* Handles buffer allocation.
* First: initialize for geqrf only
* Second: initialize for _geqrf and _orgqr
************************************************************************** */
static NPY_INLINE int
init_@geqrf@_both(GEQRF_PARAMS_t *params,
                npy_intp M_in, npy_intp N_in, npy_intp NC_in)
{
    npy_uint8 *mem_buff = NULL;
    npy_uint8 *a, *b;
    fortran_int M, N, NC, K, ld;
    size_t safe_M, safe_NC, safe_K;

    M = (fortran_int)M_in;
    N = (fortran_int)N_in;
    NC = (fortran_int)NC_in;
    K = fortran_int_min(M, N);
    ld = fortran_int_max(M, 1);
    safe_M = M;
    safe_NC = fortran_int_max(NC, N);
    safe_K = K;

    mem_buff = malloc(safe_M * safe_NC * sizeof(@ftyp@)
                   + safe_K * sizeof(@ftyp@));
    if (!mem_buff) {
        goto error;
    }
    a = mem_buff;
    b = a + safe_M * safe_NC * sizeof(@ftyp@);

    params->A = a;
    params->T = b;
    params->M = M;
    params->N = N;
    params->K = K;
    params->NC = NC;
    params->LDA = ld;
    params->LWR = -1;
    params->LWQ = -1;
    params->INFO = 0;

    call_@geqrf@(params);
    if (params->INFO < 0) {
        goto error;
    }
    return 1;
  error:
    free(mem_buff);
    memset(params, 0, sizeof(*params));
    // PyErr_NoMemory();

    return 0;
}

static NPY_INLINE int
init_@geqrf@(GEQRF_PARAMS_t *params,
                npy_intp M_in, npy_intp N_in, npy_intp NC_in)
{
    npy_uint8 *mem_buff2 = NULL;
    npy_uint8 *c;
    fortran_int LWR;
    size_t safe_LWR;
    @ftyp@ work_size;

    params->WR = &work_size;
    params->WQ = NULL;
    if (!init_@geqrf@_both(params, M_in, N_in, NC_in)) {
        goto error;
    }
    LWR = @TYPE@_to_int(work_size);
    safe_LWR = LWR;

    mem_buff2 = malloc(safe_LWR * sizeof(@ftyp@));
    if (!mem_buff2) {
        goto error;
    }
    c = mem_buff2;

    params->WR = c;
    params->LWR = LWR;
    params->INFO = 0;

    return 1;
  error:
    free(params->A);
    free(mem_buff2);
    memset(params, 0, sizeof(*params));
    // PyErr_NoMemory();

    return 0;
}

static NPY_INLINE int
init_@orgqr@(GEQRF_PARAMS_t *params,
                npy_intp M_in, npy_intp N_in, npy_intp NC_in)
{
    npy_uint8 *mem_buff2 = NULL;
    npy_uint8 *c, *d;
    fortran_int LWR, LWQ;
    size_t safe_LWR, safe_LWQ;
    @ftyp@ work_size;

    params->WR = &work_size;
    params->WQ = &work_size;
    if (!init_@geqrf@_both(params, M_in, N_in, NC_in)) {
        goto error;
    }
    LWR = @TYPE@_to_int(work_size);
    safe_LWR = LWR;

    call_@orgqr@(params);
    if (params->INFO < 0) {
        goto error;
    }
    LWQ = @TYPE@_to_int(work_size);
    safe_LWQ = LWQ;

    mem_buff2 = malloc(safe_LWR * sizeof(@ftyp@)
                    + safe_LWQ * sizeof(@ftyp@));
    if (!mem_buff2) {
        goto error;
    }
    c = mem_buff2;
    d = c + safe_LWR * sizeof(@ftyp@);

    params->WR = c;
    params->WQ = d;
    params->LWR = LWR;
    params->LWQ = LWQ;
    params->INFO = 0;

    return 1;
  error:
    free(params->A);
    free(mem_buff2);
    memset(params, 0, sizeof(*params));
    // PyErr_NoMemory();

    return 0;
}

/* ********************
* Deallocate buffer   *
*********************** */

static NPY_INLINE void
release_@TYPE@_qr(GEQRF_PARAMS_t *params)
{
    /* 1st memory block base is in A, second in WR */
    free(params->A);
    free(params->WR);
    memset(params, 0, sizeof(*params));
}


 /* ********************
* Inner GUfunc loop    *
********************** */

static int
do_@TYPE@_qr(const void *A, void *Q, void *R,
             GEQRF_PARAMS_t *params,
             const LINEARIZE_DATA_t *a_in,  LINEARIZE_DATA_t *q_out,
             const LINEARIZE_DATA_t *r_out)
{
    // copy input to buffer
    linearize_@TYPE@_matrix(params->A, A, a_in);
    // QR decompose
    call_@geqrf@(params);
    if (params->INFO < 0) {
      return 1;
    }
    // Zero out R
    zero_@TYPE@_matrix(R, r_out);
    // Copy R from buffer & triangularise
    delinearize_@TYPE@_triu(R, params->A, r_out);
    // Build Q
    call_@orgqr@(params);
    if (params->INFO < 0) {
      return 1;
    }
    // Copy Q from buffer
    delinearize_@TYPE@_matrix(Q, params->A, q_out);
    return 0;
}

static void
@TYPE@_qr(char **args, npy_intp *dimensions, npy_intp *steps, int complete)
{
INIT_OUTER_LOOP_3
    npy_intp len_m = *dimensions++;  // rows
    npy_intp len_n = *dimensions++;  // columns
    npy_intp stride_a_m = *steps++;  // rows
    npy_intp stride_a_n = *steps++;
    npy_intp stride_q_m = *steps++;  // rows
    npy_intp stride_q_k = *steps++;
    npy_intp stride_r_k = *steps++;  // rows
    npy_intp stride_r_n = *steps++;
    int error_occurred = get_fp_invalid_and_clear();
    GEQRF_PARAMS_t params;
    LINEARIZE_DATA_t a_in, q_out, r_out;
    npy_intp len_nc = complete ? len_m : len_n;

    if(len_m < len_nc) {//signature demands a wide matrix for q, impossible for qr_n.
        // PyErr_SetString(PyExc_ValueError, "qr_n can only be called when m >= n.");
        error_occurred = 1;
        init_linearize_data(&q_out, len_nc, len_m, stride_q_k, stride_q_m);
        init_linearize_data_ex(&r_out, len_n, len_nc, stride_r_n, stride_r_k, len_m);
        nan_@TYPE@_matrix(args[1], &q_out);
        nan_@TYPE@_matrix(args[2], &r_out);
    } else {
        if(init_@orgqr@(&params, len_m, len_n, len_nc)){
            init_linearize_data(&a_in, len_n, len_m, stride_a_n, stride_a_m);
            init_linearize_data(&q_out, len_nc, len_m, stride_q_k, stride_q_m);
            init_linearize_data_ex(&r_out, len_n, len_nc, stride_r_n, stride_r_k, len_m);

            BEGIN_OUTER_LOOP
                int not_ok;
                not_ok = do_@TYPE@_qr(args[0], args[1], args[2], &params,
                                   &a_in, &q_out, &r_out);
                if (not_ok) {
                    error_occurred = 1;
                    nan_@TYPE@_matrix(args[1], &q_out);
                    nan_@TYPE@_matrix(args[2], &r_out);
                }
            END_OUTER_LOOP_3
            release_@TYPE@_qr(&params);
        }
    }
    set_fp_invalid_or_clear(error_occurred);
}

static void
@TYPE@_qr_r(char **args, npy_intp *dimensions, npy_intp *steps, int complete)
{
INIT_OUTER_LOOP_2
    npy_intp len_m = *dimensions++;  // rows
    npy_intp len_n = *dimensions++;  // columns
    npy_intp stride_a_m = *steps++;  // rows
    npy_intp stride_a_n = *steps++;
    npy_intp stride_r_k = *steps++;  // rows
    npy_intp stride_r_n = *steps++;
    int error_occurred = get_fp_invalid_and_clear();
    GEQRF_PARAMS_t params;
    LINEARIZE_DATA_t a_in, r_out;
    npy_intp len_nc = complete ? len_m : len_n;

    if(len_m < len_nc) {//signature demands a wide matrix for q, impossible for qr_n.
        // PyErr_SetString(PyExc_ValueError, "qr_n can only be called when m >= n.");
        error_occurred = 1;
        init_linearize_data_ex(&r_out, len_n, len_nc, stride_r_n, stride_r_k, len_m);
        nan_@TYPE@_matrix(args[1], &r_out);
    } else {
        if(init_@geqrf@(&params, len_m, len_n, len_nc)){
            init_linearize_data(&a_in, len_n, len_m, stride_a_n, stride_a_m);
            init_linearize_data_ex(&r_out, len_n, len_nc, stride_r_n, stride_r_k, len_m);

            BEGIN_OUTER_LOOP
                // copy input to buffer
                linearize_@TYPE@_matrix(params.A, args[0], &a_in);
                // QR decompose
                call_@geqrf@(&params);
                if (params.INFO < 0) {
                    error_occurred = 1;
                    nan_@TYPE@_matrix(args[1], &r_out);
                } else{
                    // Zero out R
                    zero_@TYPE@_matrix(args[1], &r_out);
                    // Copy R from buffer & triangularise
                    delinearize_@TYPE@_triu(args[1], params.A, &r_out);
                }
            END_OUTER_LOOP_2
            release_@TYPE@_qr(&params);
        }
    }
    set_fp_invalid_or_clear(error_occurred);
}

static void
@TYPE@_qr_raw(char **args, npy_intp *dimensions, npy_intp *steps, int complete)
{
INIT_OUTER_LOOP_3
    npy_intp len_m = *dimensions++;  // rows
    npy_intp len_n = *dimensions++;  // columns
    npy_intp stride_a_m = *steps++;  // rows
    npy_intp stride_a_n = *steps++;
    npy_intp stride_r_n = *steps++;  // rows
    npy_intp stride_r_m = *steps++;
    npy_intp stride_tau = *steps++;
    int error_occurred = get_fp_invalid_and_clear();
    GEQRF_PARAMS_t params;
    LINEARIZE_DATA_t a_in, r_out;
    LINEARIZE_VDATA_t tau_out;
    npy_intp len_nc = complete ? len_m : len_n;

    if(len_m < len_nc) {//signature demands a wide matrix for q, impossible for qr_n.
        // PyErr_SetString(PyExc_ValueError, "qr_n can only be called when m >= n.");
        error_occurred = 1;
        init_linearize_data_ex(&r_out, len_n, len_m, stride_r_n, stride_r_m, len_m);
        init_linearize_vdata(&tau_out, len_nc, stride_tau);
        nan_@TYPE@_matrix(args[1], &r_out);
        nan_@TYPE@_vec(args[2], &tau_out);
    } else {
        if(init_@geqrf@(&params, len_m, len_n, len_nc)){
            init_linearize_data(&a_in, len_n, len_m, stride_a_n, stride_a_m);
            init_linearize_data(&r_out, len_m, len_n, stride_r_m, stride_r_n);
            init_linearize_vdata(&tau_out, len_nc, stride_tau);

            BEGIN_OUTER_LOOP
                // copy input to buffer
                linearize_@TYPE@_matrix(params.A, args[0], &a_in);
                // QR decompose
                call_@geqrf@(&params);
                if (params.INFO < 0) {
                    error_occurred = 1;
                    nan_@TYPE@_matrix(args[1], &r_out);
                    nan_@TYPE@_vec(args[1], &tau_out);
                } else{
                    // Copy r & h from buffer
                    delinearize_@TYPE@_matrix(args[1], params.A, &r_out);
                    // Copy tau from buffer
                    delinearize_@TYPE@_vec(args[2], params.T, &tau_out);
                }
            END_OUTER_LOOP_3
            release_@TYPE@_qr(&params);
        }
    }
    set_fp_invalid_or_clear(error_occurred);
}

static void
@TYPE@_qr_m(char **args, npy_intp *dimensions, npy_intp *steps,
    void *NPY_UNUSED(func))
    {
        @TYPE@_qr(args, dimensions, steps, 1);
    }

static void
@TYPE@_qr_n(char **args, npy_intp *dimensions, npy_intp *steps,
    void *NPY_UNUSED(func))
    {
        @TYPE@_qr(args, dimensions, steps, 0);
    }

static void
@TYPE@_qr_rm(char **args, npy_intp *dimensions, npy_intp *steps,
    void *NPY_UNUSED(func))
    {
        @TYPE@_qr_r(args, dimensions, steps, 1);
    }

static void
@TYPE@_qr_rn(char **args, npy_intp *dimensions, npy_intp *steps,
    void *NPY_UNUSED(func))
    {
        @TYPE@_qr_r(args, dimensions, steps, 0);
    }

static void
@TYPE@_qr_rawm(char **args, npy_intp *dimensions, npy_intp *steps,
        void *NPY_UNUSED(func))
{
    @TYPE@_qr_raw(args, dimensions, steps, 1);
}

static void
@TYPE@_qr_rawn(char **args, npy_intp *dimensions, npy_intp *steps,
        void *NPY_UNUSED(func))
{
    @TYPE@_qr_raw(args, dimensions, steps, 0);
}

/**end repeat**/

/*
******************************************************************************
**                                SOLVE                                     **
******************************************************************************
*/

// char *solve_signature = "(n,n),(n,nrhs)->(n,nrhs)";

typedef struct gesv_params_struct
{
    void *A; /* A is (N,N) of base type */
    void *B; /* B is (N,NRHS) of base type */
    fortran_int *IPIV; /* IPIV is (N,) of int type, work for _geqrf */

    fortran_int N;
    fortran_int NRHS;
    fortran_int LDA;
    fortran_int LDB;
    fortran_int INFO;
} GESV_PARAMS_t;

/**begin repeat
    #TYPE = FLOAT, DOUBLE, CFLOAT, CDOUBLE#
    #ftyp = fortran_real, fortran_doublereal, fortran_complex, fortran_doublecomplex#
    #gesv = sgesv, dgesv, cgesv, zgesv#
*/

/* ************************************************
* Calling BLAS/Lapack functions _gesv             *
*************************************************** */

static NPY_INLINE void
call_@gesv@(GESV_PARAMS_t *params)
{
    // A,B are modified by ?GESV to carry LU info & X
    LAPACK(@gesv@)(&params->N, &params->NRHS, params->A, &params->LDA,
                   params->IPIV, params->B, &params->LDB, &params->INFO);
}

/* *************************************************************************
* Initialize the parameters to use in the lapack functions _gesv           *
* Handles buffer allocation
************************************************************************** */
static NPY_INLINE int
init_@gesv@(GESV_PARAMS_t *params, npy_intp N_in, npy_intp NRHS_in)
{
    npy_uint8 *mem_buff = NULL;
    npy_uint8 *a, *b, *c;
    fortran_int N, NRHS, lda, ldb;
    size_t safe_N, safe_NRHS;

    N = (fortran_int)N_in;
    NRHS = (fortran_int)NRHS_in;
    lda = fortran_int_max(N, 1);
    ldb = fortran_int_max(N, 1);
    safe_N = N_in;
    safe_NRHS = NRHS_in;

    mem_buff = malloc(safe_N * safe_N * sizeof(@ftyp@)
                    + safe_N * safe_NRHS * sizeof(@ftyp@)
                    + safe_N * sizeof(fortran_int));
    if (!mem_buff) {
        goto error;
    }
    a = mem_buff;
    b = a + safe_N * safe_N * sizeof(@ftyp@);
    c = b + safe_N * safe_NRHS * sizeof(@ftyp@);

    params->A = a;
    params->B = b;
    params->IPIV = (fortran_int*)c;
    params->N = N;
    params->NRHS = NRHS;
    params->LDA = lda;
    params->LDB = ldb;
    params->INFO = 0;

    return 1;

  error:
    free(mem_buff);
    memset(params, 0, sizeof(*params));
    // PyErr_NoMemory();

    return 0;
}

/* **********************
* Deallocate buffer     *
*********************** */

static NPY_INLINE void
release_@gesv@(GESV_PARAMS_t *params)
{
    /* 1st memory block base is in A */
    free(params->A);
    memset(params, 0, sizeof(*params));
}


/* **********************
* Inner GUfunc loop     *
*********************** */

// solve_signature = "(n,n),(n,nrhs)->(n,nrhs)";

static void
@TYPE@_solve(char **args, npy_intp *dimensions, npy_intp *steps,
            void *NPY_UNUSED(func))
{
INIT_OUTER_LOOP_3
    npy_intp len_n = *dimensions++;  // rows
    npy_intp len_nrhs = *dimensions++;  // columns
    npy_intp stride_a_r = *steps++;  // rows
    npy_intp stride_a_c = *steps++;
    npy_intp stride_b_r = *steps++;  // rows
    npy_intp stride_b_c = *steps++;
    npy_intp stride_x_r = *steps++;  // rows
    npy_intp stride_x_c = *steps++;
    int error_occurred = get_fp_invalid_and_clear();
    GESV_PARAMS_t params;
    LINEARIZE_DATA_t a_in, b_in, x_out;

    if(init_@gesv@(&params, len_n, len_nrhs)){
        init_linearize_data(&a_in, len_n, len_n, stride_a_c, stride_a_r);
        init_linearize_data(&b_in, len_nrhs, len_n, stride_b_c, stride_b_r);
        init_linearize_data(&x_out, len_nrhs, len_n, stride_x_c, stride_x_r);

        BEGIN_OUTER_LOOP
            int not_ok;
            linearize_@TYPE@_matrix(params.A, args[0], &a_in);
            linearize_@TYPE@_matrix(params.B, args[1], &b_in);
            call_@gesv@(&params);
            not_ok = params.INFO;
            if (not_ok) {
                error_occurred = 1;
                nan_@TYPE@_matrix(args[2], &x_out);
            } else {
                delinearize_@TYPE@_matrix(args[2], params.B, &x_out);
            }
        END_OUTER_LOOP_3
        release_@gesv@(&params);
    }
    set_fp_invalid_or_clear(error_occurred);
}

// solve_signature = (nrhs,n),(n,n)->(nrhs,n)"

static void
@TYPE@_rsolve(char **args, npy_intp *dimensions, npy_intp *steps,
            void *NPY_UNUSED(func))
{
INIT_OUTER_LOOP_3
    /*swap (A,B) for (B^T,A^T)
    a,b here are not the same as A,B  in docstring: a=B^T, b=A^T */
    char *rargs[] = {args[1], args[0], args[2]};
    // dimensions = {N, len_nrhs, len_n};
    // rdimensions[] = {N, len_n, len_nrhs};
    npy_intp rdimensions[] = {dimensions[0], dimensions[2], dimensions[1]};
    // steps = {strides_b, strides_a, strides_x,
    //     strides_b_c, strides_b_r,
    //     strides_a_c, strides_a_r,
    //     strides_x_c, strides_x_r, };
    // rsteps = {strides_a, strides_b, strides_x,
    //     strides_a_r, strides_a_c,
    //     strides_b_r, strides_b_c,
    //     strides_x_r, strides_x_c, };
    npy_intp rsteps[] = {steps[1], steps[0], steps[2],
            steps[6], steps[5],
            steps[4], steps[3],
            steps[8], steps[7]};
    //now that we've swapped a,b and transposed, proceed as if we're in solve
    @TYPE@_solve(rargs, rdimensions, rsteps, NULL);
}

/**end repeat**/

 /*
******************************************************************************
**                                LSTSQ                                     **
******************************************************************************
*/

// char *lstsq_signature = "(m,n),(m,nrhs)->(n,nrhs)";

typedef struct gels_params_struct
{
    void *A; /* A is (N,N) of base type */
    void *B; /* B is (N,NRHS) of base type */
    void *W; /* W is (LW,) of base type, work for _geqrf */
    void *RW; /* RW is (LRW,) of base type, work for _geqrf */
    void *S; /* S is (MN,) of base type, work for _geqrf */
    void *RCOND; /* RCOND is scalar of base type */
    fortran_int *RANK; /* RANK is scalar of int type */
    fortran_int *IW; /* IW is (LIW,) of int type */

    fortran_int M;
    fortran_int N;
    fortran_int NRHS;
    fortran_int LDA;
    fortran_int LDB;
    fortran_int LW;
    fortran_int INFO;
} GELS_PARAMS_t;

/* ************************************************
* Calling BLAS/Lapack functions _gelsd            *
*************************************************** */

/**begin repeat
    #gels = sgelsd, dgelsd#
    #gcls = cgelsd, zgelsd#
*/
static NPY_INLINE void
call_@gels@(GELS_PARAMS_t *params)
{
    // A,B are modified by ?GELS to carry LU info & X
    LAPACK(@gels@)(&params->M, &params->N, &params->NRHS,
                   params->A, &params->LDA, params->B, &params->LDB,
                   params->S, params->RCOND, params->RANK,
                   params->W, &params->LW, params->IW, &params->INFO);
}

static NPY_INLINE void
call_@gcls@(GELS_PARAMS_t *params)
{
    // A,B are modified by ?GELS to carry LU info & X
    LAPACK(@gcls@)(&params->M, &params->N, &params->NRHS,
                   params->A, &params->LDA, params->B, &params->LDB,
                   params->S, params->RCOND, params->RANK, params->W,
                   &params->LW, params->RW, params->IW, &params->INFO);
}
/**end repeat**/

/* *************************************************************************
* Initialize the parameters to use in the lapack functions _gelsd          *
* Handles buffer allocation
************************************************************************** */

/**begin repeat
    #ftyp = fortran_real, fortran_doublereal, fortran_complex, fortran_doublecomplex#
    #rftyp = fortran_real, fortran_doublereal, fortran_real, fortran_doublereal#
    #gels = sgelsd, dgelsd, cgelsd, zgelsd#
    #eps = s_eps, d_eps, s_eps, d_eps#
*/
static NPY_INLINE int
init_@gels@_both(GELS_PARAMS_t *params,
            npy_intp M_in, npy_intp N_in, npy_intp NRHS_in)
{
    npy_uint8 *mem_buff = NULL;
    npy_uint8 *a, *b, *c, *d, *e;
    fortran_int M, N, NRHS, MNn, MNx, lda, ldb;
    size_t safe_M, safe_N, safe_NRHS, safe_MNn, safe_MNx;

    M = (fortran_int)M_in;
    N = (fortran_int)N_in;
    NRHS = (fortran_int)NRHS_in;
    MNn = fortran_int_min(M, N);
    MNx = fortran_int_max(M, N);
    lda = fortran_int_max(M, 1);
    ldb = fortran_int_max(MNx, 1);
    safe_M = M_in;
    safe_N = N_in;
    safe_NRHS = NRHS_in;
    safe_MNn = MNn;
    safe_MNx = MNx;

    mem_buff = malloc(safe_M * safe_N * sizeof(@ftyp@)
                    + safe_MNx * safe_NRHS * sizeof(@ftyp@)
                    + safe_MNn  * sizeof(@rftyp@)
                    + sizeof(@rftyp@) + sizeof(fortran_int));
    if (!mem_buff) {
        goto error;
    }
    a = mem_buff;
    b = a + safe_M * safe_N * sizeof(@ftyp@);
    c = b + safe_MNx * safe_NRHS * sizeof(@ftyp@);
    d = c + safe_MNn * sizeof(@rftyp@);
    e = d + sizeof(@rftyp@);

    params->A = a;
    params->B = b;
    params->S = c;
    params->RCOND = d;
    params->RANK = (fortran_int*)e;
    params->M = M;
    params->N = N;
    params->NRHS = NRHS;
    params->LDA = lda;
    params->LDB = ldb;
    params->LW = -1;
    params->INFO = 0;

    *(@rftyp@ *)params->RCOND = MNx * @eps@;

    call_@gels@(params);
    if (params->INFO) {
        goto error;
    }
    return 1;

  error:
    free(mem_buff);
    memset(params, 0, sizeof(*params));
    // PyErr_NoMemory();

    return 0;
}
/**end repeat**/

/**begin repeat
    #ftyp = fortran_real, fortran_doublereal#
    #cftyp = fortran_complex, fortran_doublecomplex#
    #gels = sgelsd, dgelsd#
    #gcls = cgelsd, zgelsd#
*/

static NPY_INLINE int
init_@gels@(GELS_PARAMS_t *params,
            npy_intp M_in, npy_intp N_in, npy_intp NRHS_in)
{
    npy_uint8 *mem_buff2 = NULL;
    npy_uint8 *a, *b;
    fortran_int LW, iwork_size;
    size_t safe_LW, safe_LIW;
    @ftyp@ work_size;

    params->W = &work_size;
    params->IW = &iwork_size;
    if (!init_@gels@_both(params, M_in, N_in, NRHS_in)) {
        goto error;
    }
    LW = (fortran_int)work_size;
    safe_LW = LW;
    safe_LIW = iwork_size;

    mem_buff2 = malloc(safe_LW * sizeof(@ftyp@)
                    + safe_LIW * sizeof(fortran_int));
    if (!mem_buff2) {
        goto error;
    }
    a = mem_buff2;
    b = a + safe_LW * sizeof(@ftyp@);

    params->W = a;
    params->IW = (fortran_int*)b;
    params->LW = LW;

    return 1;

  error:
    free(params->A);
    free(mem_buff2);
    memset(params, 0, sizeof(*params));
    PyErr_NoMemory();

    return 0;
}

static NPY_INLINE int
init_@gcls@(GELS_PARAMS_t *params,
            npy_intp M_in, npy_intp N_in, npy_intp NRHS_in)
{
    npy_uint8 *mem_buff2 = NULL;
    npy_uint8 *a, *b, *c;
    fortran_int LW, iwork_size;
    size_t safe_LW, safe_LRW, safe_LIW;
    @cftyp@ work_size;
    @ftyp@ rwork_size;

    params->W = &work_size;
    params->RW = &rwork_size;
    params->IW = &iwork_size;
    if (!init_@gcls@_both(params, M_in, N_in, NRHS_in)) {
        goto error;
    }
    LW = (fortran_int)work_size.r;
    safe_LW = LW;
    safe_LRW = (size_t)rwork_size;
    safe_LIW = iwork_size;

    mem_buff2 = malloc(safe_LW * sizeof(@cftyp@)
                    + safe_LRW * sizeof(@ftyp@)
                    + safe_LIW * sizeof(fortran_int));
    if (!mem_buff2) {
        goto error;
    }
    a = mem_buff2;
    b = a + safe_LW * sizeof(@cftyp@);
    c = b + safe_LRW * sizeof(@ftyp@);

    params->W = a;
    params->RW = b;
    params->IW = (fortran_int*)c;
    params->LW = LW;

    return 1;

  error:
    free(params->A);
    free(mem_buff2);
    memset(params, 0, sizeof(*params));
    PyErr_NoMemory();

    return 0;
}

/**end repeat**/

/**begin repeat
    #TYPE = FLOAT, DOUBLE, CFLOAT, CDOUBLE#
    #gels = sgelsd, dgelsd, cgelsd, zgelsd#
*/

/* ********************
* Deallocate buffer   *
*********************** */

static NPY_INLINE void
release_@gels@(GELS_PARAMS_t *params)
{
   /* 1st memory block base is in A, second in W */
   free(params->A);
   free(params->W);
   memset(params, 0, sizeof(*params));
}


/* ********************
* Inner GUfunc loop   *
********************* */

// lstsq_signature = "(m,n),(m,nrhs)->(n,nrhs)";

static void
@TYPE@_lstsq(char **args, npy_intp *dimensions, npy_intp *steps,
                void *NPY_UNUSED(func))
{
INIT_OUTER_LOOP_3
    npy_intp len_m = *dimensions++;  // rows of a, b
    npy_intp len_n = *dimensions++;  // columns of a, rows of x
    npy_intp len_nrhs = *dimensions++;  // columns of x, b
    npy_intp stride_a_r = *steps++;  // rows
    npy_intp stride_a_c = *steps++;
    npy_intp stride_b_r = *steps++;  // rows
    npy_intp stride_b_c = *steps++;
    npy_intp stride_x_r = *steps++;  // rows
    npy_intp stride_x_c = *steps++;
    int error_occurred = get_fp_invalid_and_clear();
    GELS_PARAMS_t params;
    LINEARIZE_DATA_t a_in, b_in, x_out;
    npy_intp len_mn = len_m > len_n ? len_m : len_n; // max

    if(init_@gels@(&params, len_m, len_n, len_nrhs)){
        init_linearize_data(&a_in, len_n, len_m, stride_a_c, stride_a_r);
        init_linearize_data_ex(&b_in, len_nrhs, len_m, stride_b_c, stride_b_r, len_mn);
        init_linearize_data_ex(&x_out, len_nrhs, len_n, stride_x_c, stride_x_r, len_mn);

        BEGIN_OUTER_LOOP
            int not_ok;
            linearize_@TYPE@_matrix(params.A, args[0], &a_in);
            linearize_@TYPE@_matrix(params.B, args[1], &b_in);
            call_@gels@(&params);
            not_ok = params.INFO;
            if (not_ok) {
                error_occurred = 1;
                nan_@TYPE@_matrix(args[2], &x_out);
            } else {
                delinearize_@TYPE@_matrix(args[2], params.B, &x_out);
            }
        END_OUTER_LOOP_3
        release_@gels@(&params);
    }
    set_fp_invalid_or_clear(error_occurred);
}

// lstsq_signature = "(nrhs,m),(n,m)->(nrhs,n)"

static void
@TYPE@_rlstsq(char **args, npy_intp *dimensions, npy_intp *steps,
void *NPY_UNUSED(func))
{
    /*swap (A,B) for (B^T,A^T)
    a,b here are not the same as A,B  in docstring: a=B^T, b=A^T */
    char *rargs[] = {args[1], args[0], args[2]};
    // dimensions = {N, len_nrhs, len_m, len_n};
    // rdimensions[] = {N, len_m, len_n, len_nrhs};
    npy_intp rdimensions[] = {dimensions[0], dimensions[2], dimensions[3], dimensions[1]};
    // steps = {strides_b, strides_a, strides_x,
    //     strides_b_c, strides_b_r,
    //     strides_a_c, strides_a_r,
    //     strides_x_c, strides_x_r, };
    // rsteps = {strides_a, strides_b, strides_x,
    //     strides_a_r, strides_a_c,
    //     strides_b_r, strides_b_c,
    //     strides_x_r, strides_x_c, };
    npy_intp rsteps[] = {steps[1], steps[0], steps[2],
        steps[6], steps[5],
        steps[4], steps[3],
        steps[8], steps[7]};
    //now that we've swapped a,b and transposed, proceed as if we're in lstsq
    @TYPE@_lstsq(rargs, rdimensions, rsteps, NULL);
}

/**end repeat**/

/*
*****************************************************************************
**                             Ufunc definition                            **
*****************************************************************************
*/


GUFUNC_FUNC_ARRAY_REAL_COMPLEX(qr_m);
GUFUNC_FUNC_ARRAY_REAL_COMPLEX(qr_n);
GUFUNC_FUNC_ARRAY_REAL_COMPLEX(qr_rm);
GUFUNC_FUNC_ARRAY_REAL_COMPLEX(qr_rn);
GUFUNC_FUNC_ARRAY_REAL_COMPLEX(qr_rawm);
GUFUNC_FUNC_ARRAY_REAL_COMPLEX(qr_rawn);
GUFUNC_FUNC_ARRAY_REAL_COMPLEX(solve);
GUFUNC_FUNC_ARRAY_REAL_COMPLEX(rsolve);
GUFUNC_FUNC_ARRAY_REAL_COMPLEX(lstsq);
GUFUNC_FUNC_ARRAY_REAL_COMPLEX(rlstsq);

GUFUNC_DESCRIPTOR_t gufunc_descriptors[] = {
    { "qr_m", "(m,n)->(m,m),(m,n)", qr__doc__, 4, 1, 2,
        FUNC_ARRAY_NAME(qr_m), ufn_types_4_3 },
    { "qr_n", "(m,n)->(m,n),(n,n)", qr__doc__, 4, 1, 2,
        FUNC_ARRAY_NAME(qr_n), ufn_types_4_3 },
    { "qr_rm", "(m,n)->(m,n)", qr__doc__, 4, 1, 1,
        FUNC_ARRAY_NAME(qr_rm), ufn_types_4_2 },
    { "qr_rn", "(m,n)->(n,n)", qr__doc__, 4, 1, 1,
        FUNC_ARRAY_NAME(qr_rn), ufn_types_4_2 },
    { "qr_rawm", "(m,n)->(n,m),(m)", qr__doc__, 4, 1, 2,
        FUNC_ARRAY_NAME(qr_rawm), ufn_types_4_3 },
    { "qr_rawn", "(m,n)->(n,m),(n)", qr__doc__, 4, 1, 2,
        FUNC_ARRAY_NAME(qr_rawn), ufn_types_4_3 },
    { "solve", "(n,n),(n,nrhs)->(n,nrhs)", solve__doc__, 4, 2, 1,
        FUNC_ARRAY_NAME(solve), ufn_types_4_3 },
    { "rsolve", "(nrhs,n),(n,n)->(nrhs,n)", solve__doc__, 4, 2, 1,
        FUNC_ARRAY_NAME(solve), ufn_types_4_3 },
    { "lstsq", "(m,n),(m,nrhs)->(n,nrhs)", lstsq__doc__, 4, 2, 1,
        FUNC_ARRAY_NAME(lstsq), ufn_types_4_3 },
    { "rlstsq", "(nrhs,m),(n,m)->(nrhs,n)", lstsq__doc__, 4, 2, 1,
        FUNC_ARRAY_NAME(lstsq), ufn_types_4_3 }
};

/*
*****************************************************************************
**               Module initialization stuff                               **
*****************************************************************************
*/

static PyMethodDef GUfuncs_LAPACK_Methods[] = {
    {NULL, NULL, 0, NULL}        /* Sentinel */
};

static struct PyModuleDef moduledef = {
    PyModuleDef_HEAD_INIT,
    "_gufuncs_lapack",
    NULL,
    -1,
    GUfuncs_LAPACK_Methods,
    NULL,
    NULL,
    NULL,
    NULL
};

PyObject *PyInit__gufuncs_lapack(void)
{
    PyObject *m;
    PyObject *d;
    PyObject *version;

    init_constants();
    m = PyModule_Create(&moduledef);
    if (m == NULL) {
        return NULL;
    }

    import_array();
    import_ufunc();

    d = PyModule_GetDict(m);

    version = PyString_FromString(gufuncs_lapack_version_string);
    PyDict_SetItemString(d, "__version__", version);
    Py_DECREF(version);

    /* Load the ufunc operators into the module's namespace */
    int failure = addUfuncs(d, gufunc_descriptors, 10);

    if (PyErr_Occurred() || failure) {
        PyErr_SetString(PyExc_RuntimeError,
                        "cannot load _gufuncs_lapack module.");
        return NULL;
    }

    return m;
}
