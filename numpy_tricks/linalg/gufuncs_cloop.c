
/*
 *****************************************************************************
 **       This file was autogenerated from a template  DO NOT EDIT!!!!      **
 **       Changes should be made to the original source (.src) file         **
 *****************************************************************************
 */

#line 1
/* -*- Mode: C -*- */
/*
Adapted from https://github.com/numpy/numpy/numpy/linalg/umath_linalg.c.src
Copyright/licence info for that file:
* Copyright (c) 2005-2017, NumPy Developers.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
*   - Redistributions of source code must retain the above
*     copyright notice, this list of conditions and the
*     following disclaimer.
*   - Redistributions in binary form must reproduce the above copyright
*     notice, this list of conditions and the following disclaimer
*     in the documentation and/or other materials provided with the
*     distribution.
*   - Neither the name of the author nor the names of its
*     contributors may be used to endorse or promote products derived
*     from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
* A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*              Table of Contents
50.  Includes
61.  Docstrings
114. UFUNC LOOPS
    119. matmul
    208. rmatmul
    242. norm
    306. rtrue_divide
417. Ufunc definition
439. Module initialization stuff
*/

/*
*****************************************************************************
**                            Includes                                     **
*****************************************************************************
*/
#define NPY_NO_DEPRECATED_API NPY_API_VERSION

#include "gufunc_common.h"

static const char* gufuncs_cloop_version_string = "0.1.1";

/*
*****************************************************************************
**                   Doc string for Python functions                       **
*****************************************************************************
*/

PyDoc_STRVAR(matmul__doc__,
//"matmul(X: ndarray, Y: ndarray) -> (Z: ndarray)\n\n"
"Matrix-matrix product.\n\n"
"Parameters\n-----------\n"
"X: ndarray (...,M,N)\n"
"    Matrix multiplying from left.\n"
"Y: ndarray (...,N,P)\n"
"    Matrix multiplying from right.\n\n"
"Returns\n-------\n"
"Z: ndarray (...,M,P)\n"
"    Result of matrix multiplication.");

PyDoc_STRVAR(rmatmul__doc__,
//"matmul(Y: ndarray, X: ndarray) -> (Z: ndarray)\n\n"
"Reversed matrix-matrix product.\n\n"
"Parameters\n-----------\n"
"Y: ndarray (...,N,P)\n"
"    Matrix multiplying from right.\n"
"X: ndarray (...,M,N)\n"
"    Matrix multiplying from left.\n\n"
"Returns\n-------\n"
"Z: ndarray (...,M,P)\n"
"    Result of matrix multiplication.");

PyDoc_STRVAR(norm__doc__,
//"matmul(X: ndarray, Y: ndarray) -> (Z: ndarray)\n\n"
"Euclidean norm of a vector.\n"
"Unlike `numpy.linalg.norm`, it only computes the vector 2-norm.\n\n"
"Parameters\n-----------\n"
"X: ndarray (...,N)\n"
"    Vector, or array of vectors.\n\n"
"Returns\n-------\n"
"Z: float\n"
"    Euclidean norm of X.");

PyDoc_STRVAR(rtruedivide__doc__,
//"matmul(Y: ndarray, X: ndarray) -> (Z: ndarray)\n\n"
"Reversed division Z = X \\ Y.\n\n"
"Parameters\n-----------\n"
"X: ndarray (...)\n"
"    Denominator.\n"
"Y: ndarray (...)\n"
"    Numerator.\n\n"
"Returns\n-------\n"
"Z: ndarray (...)\n"
"    Result of division.");

/*
*****************************************************************************
**                             Ufunc loops                                 **
*****************************************************************************
*/

/********************************
*            MATMUL             *
*********************************/

#line 125
static void
CFLOAT_add_product_scalar(const COMPLEX_t *x_in, const COMPLEX_t *y_in, COMPLEX_t *z_out)
{
    z_out->array[0] += x_in->array[0] * y_in->array[0];
    z_out->array[0] -= x_in->array[1] * y_in->array[1];
    z_out->array[1] += x_in->array[0] * y_in->array[1];
    z_out->array[1] += x_in->array[1] * y_in->array[0];
}

#line 125
static void
CDOUBLE_add_product_scalar(const DOUBLECOMPLEX_t *x_in, const DOUBLECOMPLEX_t *y_in, DOUBLECOMPLEX_t *z_out)
{
    z_out->array[0] += x_in->array[0] * y_in->array[0];
    z_out->array[0] -= x_in->array[1] * y_in->array[1];
    z_out->array[1] += x_in->array[0] * y_in->array[1];
    z_out->array[1] += x_in->array[1] * y_in->array[0];
}


#line 141

// matmul_signature = "(m,n),(n,p)->(m,p)";

static void
INT_matmul(char **args, npy_intp *dimensions, npy_intp *steps,
              void *NPY_UNUSED(func))
{
INIT_OUTER_LOOP_3

    npy_intp len_m = *dimensions++;  // dimensions of left
    npy_intp len_n = *dimensions++;  // dimensions of inner
    npy_intp len_p = *dimensions++;  // dimensions of right
    npy_intp stride_x_m = *steps++;  // 1st arg
    npy_intp stride_x_n = *steps++;
    npy_intp stride_y_n = *steps++;  // 2nd arg
    npy_intp stride_y_p = *steps++;
    npy_intp stride_z_m = *steps++;  // output
    npy_intp stride_z_p = *steps++;
    npy_intp m, n, p;
    npy_intp iback_x_n = len_n * stride_x_n;  // step back at end of loop
    npy_intp iback_y_n = len_n * stride_y_n;
    npy_intp iback_y_p = len_p * stride_y_p;  // step back at end of loop
    npy_intp iback_z_p = len_p * stride_z_p;

    BEGIN_OUTER_LOOP

        const char *ip_x= args[0];  //  1st arg
        const char *ip_y= args[1];  //  2nd arg
        char *op_z = args[2];       //  output

        for (m = 0; m < len_m; m++) {
            for (p = 0; p < len_p; p++) {
                *(npy_int *)op_z = 0;

                for (n = 0; n < len_n; n++) {
#if 0
                        INT_add_product_scalar((npy_int *)ip_x, (npy_int *)ip_y, (npy_int *)op_z);
#else
                        *(npy_int *)op_z += *(npy_int *)ip_x * *(npy_int *)ip_y;
#endif


                    ip_x += stride_x_n;
                    ip_y += stride_y_n;
                }
                ip_x -= iback_x_n;
                ip_y -= iback_y_n;

                ip_y += stride_y_p;
                op_z += stride_z_p;
            }
            ip_y -= iback_y_p;
            op_z -= iback_z_p;

            ip_x += stride_x_m;
            op_z += stride_z_m;
        }

    END_OUTER_LOOP_3
}

/********************************
*           RMATMUL             *
*********************************/

// rmatmul_signature = "(n,p),(m,n)->(m,p)";

static void
INT_rmatmul(char **args, npy_intp *dimensions, npy_intp *steps,
              void *NPY_UNUSED(func))
{
    /*swap (X,Y) for (Y,X)
    x,y here are not the same as X,Y  in docstring: x=Y, y=X */
    char *rargs[] = {args[1], args[0], args[2]};
    // dimensions = {N, len_n, len_p, len_m};
    // rdimensions[] = {N, len_m, len_n, len_p};
    npy_intp rdimensions[] = {dimensions[0], dimensions[3], dimensions[1], dimensions[2]};
    // steps = {strides_y, strides_x, strides_z,
    //     strides_y_r, strides_y_c,
    //     strides_x_r, strides_x_c,
    //     strides_z_r, strides_z_c, };
    // rsteps = {strides_x, strides_y, strides_z,
    //     strides_x_r, strides_x_c,
    //     strides_y_r, strides_y_c,
    //     strides_z_r, strides_z_c, };
    npy_intp rsteps[] = {steps[1], steps[0], steps[2],
        steps[5], steps[6],
        steps[3], steps[4],
        steps[7], steps[8]};
    //now that we've swapped a,b and transposed, proceed as if we're in matmul
    INT_matmul(rargs, rdimensions, rsteps, NULL);
}


#line 141

// matmul_signature = "(m,n),(n,p)->(m,p)";

static void
FLOAT_matmul(char **args, npy_intp *dimensions, npy_intp *steps,
              void *NPY_UNUSED(func))
{
INIT_OUTER_LOOP_3

    npy_intp len_m = *dimensions++;  // dimensions of left
    npy_intp len_n = *dimensions++;  // dimensions of inner
    npy_intp len_p = *dimensions++;  // dimensions of right
    npy_intp stride_x_m = *steps++;  // 1st arg
    npy_intp stride_x_n = *steps++;
    npy_intp stride_y_n = *steps++;  // 2nd arg
    npy_intp stride_y_p = *steps++;
    npy_intp stride_z_m = *steps++;  // output
    npy_intp stride_z_p = *steps++;
    npy_intp m, n, p;
    npy_intp iback_x_n = len_n * stride_x_n;  // step back at end of loop
    npy_intp iback_y_n = len_n * stride_y_n;
    npy_intp iback_y_p = len_p * stride_y_p;  // step back at end of loop
    npy_intp iback_z_p = len_p * stride_z_p;

    BEGIN_OUTER_LOOP

        const char *ip_x= args[0];  //  1st arg
        const char *ip_y= args[1];  //  2nd arg
        char *op_z = args[2];       //  output

        for (m = 0; m < len_m; m++) {
            for (p = 0; p < len_p; p++) {
                *(npy_float *)op_z = s_zero;

                for (n = 0; n < len_n; n++) {
#if 0
                        FLOAT_add_product_scalar((npy_float *)ip_x, (npy_float *)ip_y, (npy_float *)op_z);
#else
                        *(npy_float *)op_z += *(npy_float *)ip_x * *(npy_float *)ip_y;
#endif


                    ip_x += stride_x_n;
                    ip_y += stride_y_n;
                }
                ip_x -= iback_x_n;
                ip_y -= iback_y_n;

                ip_y += stride_y_p;
                op_z += stride_z_p;
            }
            ip_y -= iback_y_p;
            op_z -= iback_z_p;

            ip_x += stride_x_m;
            op_z += stride_z_m;
        }

    END_OUTER_LOOP_3
}

/********************************
*           RMATMUL             *
*********************************/

// rmatmul_signature = "(n,p),(m,n)->(m,p)";

static void
FLOAT_rmatmul(char **args, npy_intp *dimensions, npy_intp *steps,
              void *NPY_UNUSED(func))
{
    /*swap (X,Y) for (Y,X)
    x,y here are not the same as X,Y  in docstring: x=Y, y=X */
    char *rargs[] = {args[1], args[0], args[2]};
    // dimensions = {N, len_n, len_p, len_m};
    // rdimensions[] = {N, len_m, len_n, len_p};
    npy_intp rdimensions[] = {dimensions[0], dimensions[3], dimensions[1], dimensions[2]};
    // steps = {strides_y, strides_x, strides_z,
    //     strides_y_r, strides_y_c,
    //     strides_x_r, strides_x_c,
    //     strides_z_r, strides_z_c, };
    // rsteps = {strides_x, strides_y, strides_z,
    //     strides_x_r, strides_x_c,
    //     strides_y_r, strides_y_c,
    //     strides_z_r, strides_z_c, };
    npy_intp rsteps[] = {steps[1], steps[0], steps[2],
        steps[5], steps[6],
        steps[3], steps[4],
        steps[7], steps[8]};
    //now that we've swapped a,b and transposed, proceed as if we're in matmul
    FLOAT_matmul(rargs, rdimensions, rsteps, NULL);
}


#line 141

// matmul_signature = "(m,n),(n,p)->(m,p)";

static void
DOUBLE_matmul(char **args, npy_intp *dimensions, npy_intp *steps,
              void *NPY_UNUSED(func))
{
INIT_OUTER_LOOP_3

    npy_intp len_m = *dimensions++;  // dimensions of left
    npy_intp len_n = *dimensions++;  // dimensions of inner
    npy_intp len_p = *dimensions++;  // dimensions of right
    npy_intp stride_x_m = *steps++;  // 1st arg
    npy_intp stride_x_n = *steps++;
    npy_intp stride_y_n = *steps++;  // 2nd arg
    npy_intp stride_y_p = *steps++;
    npy_intp stride_z_m = *steps++;  // output
    npy_intp stride_z_p = *steps++;
    npy_intp m, n, p;
    npy_intp iback_x_n = len_n * stride_x_n;  // step back at end of loop
    npy_intp iback_y_n = len_n * stride_y_n;
    npy_intp iback_y_p = len_p * stride_y_p;  // step back at end of loop
    npy_intp iback_z_p = len_p * stride_z_p;

    BEGIN_OUTER_LOOP

        const char *ip_x= args[0];  //  1st arg
        const char *ip_y= args[1];  //  2nd arg
        char *op_z = args[2];       //  output

        for (m = 0; m < len_m; m++) {
            for (p = 0; p < len_p; p++) {
                *(npy_double *)op_z = d_zero;

                for (n = 0; n < len_n; n++) {
#if 0
                        DOUBLE_add_product_scalar((npy_double *)ip_x, (npy_double *)ip_y, (npy_double *)op_z);
#else
                        *(npy_double *)op_z += *(npy_double *)ip_x * *(npy_double *)ip_y;
#endif


                    ip_x += stride_x_n;
                    ip_y += stride_y_n;
                }
                ip_x -= iback_x_n;
                ip_y -= iback_y_n;

                ip_y += stride_y_p;
                op_z += stride_z_p;
            }
            ip_y -= iback_y_p;
            op_z -= iback_z_p;

            ip_x += stride_x_m;
            op_z += stride_z_m;
        }

    END_OUTER_LOOP_3
}

/********************************
*           RMATMUL             *
*********************************/

// rmatmul_signature = "(n,p),(m,n)->(m,p)";

static void
DOUBLE_rmatmul(char **args, npy_intp *dimensions, npy_intp *steps,
              void *NPY_UNUSED(func))
{
    /*swap (X,Y) for (Y,X)
    x,y here are not the same as X,Y  in docstring: x=Y, y=X */
    char *rargs[] = {args[1], args[0], args[2]};
    // dimensions = {N, len_n, len_p, len_m};
    // rdimensions[] = {N, len_m, len_n, len_p};
    npy_intp rdimensions[] = {dimensions[0], dimensions[3], dimensions[1], dimensions[2]};
    // steps = {strides_y, strides_x, strides_z,
    //     strides_y_r, strides_y_c,
    //     strides_x_r, strides_x_c,
    //     strides_z_r, strides_z_c, };
    // rsteps = {strides_x, strides_y, strides_z,
    //     strides_x_r, strides_x_c,
    //     strides_y_r, strides_y_c,
    //     strides_z_r, strides_z_c, };
    npy_intp rsteps[] = {steps[1], steps[0], steps[2],
        steps[5], steps[6],
        steps[3], steps[4],
        steps[7], steps[8]};
    //now that we've swapped a,b and transposed, proceed as if we're in matmul
    DOUBLE_matmul(rargs, rdimensions, rsteps, NULL);
}


#line 141

// matmul_signature = "(m,n),(n,p)->(m,p)";

static void
CFLOAT_matmul(char **args, npy_intp *dimensions, npy_intp *steps,
              void *NPY_UNUSED(func))
{
INIT_OUTER_LOOP_3

    npy_intp len_m = *dimensions++;  // dimensions of left
    npy_intp len_n = *dimensions++;  // dimensions of inner
    npy_intp len_p = *dimensions++;  // dimensions of right
    npy_intp stride_x_m = *steps++;  // 1st arg
    npy_intp stride_x_n = *steps++;
    npy_intp stride_y_n = *steps++;  // 2nd arg
    npy_intp stride_y_p = *steps++;
    npy_intp stride_z_m = *steps++;  // output
    npy_intp stride_z_p = *steps++;
    npy_intp m, n, p;
    npy_intp iback_x_n = len_n * stride_x_n;  // step back at end of loop
    npy_intp iback_y_n = len_n * stride_y_n;
    npy_intp iback_y_p = len_p * stride_y_p;  // step back at end of loop
    npy_intp iback_z_p = len_p * stride_z_p;

    BEGIN_OUTER_LOOP

        const char *ip_x= args[0];  //  1st arg
        const char *ip_y= args[1];  //  2nd arg
        char *op_z = args[2];       //  output

        for (m = 0; m < len_m; m++) {
            for (p = 0; p < len_p; p++) {
                *(COMPLEX_t *)op_z = c_zero;

                for (n = 0; n < len_n; n++) {
#if 1
                        CFLOAT_add_product_scalar((COMPLEX_t *)ip_x, (COMPLEX_t *)ip_y, (COMPLEX_t *)op_z);
#else
                        *(COMPLEX_t *)op_z += *(COMPLEX_t *)ip_x * *(COMPLEX_t *)ip_y;
#endif


                    ip_x += stride_x_n;
                    ip_y += stride_y_n;
                }
                ip_x -= iback_x_n;
                ip_y -= iback_y_n;

                ip_y += stride_y_p;
                op_z += stride_z_p;
            }
            ip_y -= iback_y_p;
            op_z -= iback_z_p;

            ip_x += stride_x_m;
            op_z += stride_z_m;
        }

    END_OUTER_LOOP_3
}

/********************************
*           RMATMUL             *
*********************************/

// rmatmul_signature = "(n,p),(m,n)->(m,p)";

static void
CFLOAT_rmatmul(char **args, npy_intp *dimensions, npy_intp *steps,
              void *NPY_UNUSED(func))
{
    /*swap (X,Y) for (Y,X)
    x,y here are not the same as X,Y  in docstring: x=Y, y=X */
    char *rargs[] = {args[1], args[0], args[2]};
    // dimensions = {N, len_n, len_p, len_m};
    // rdimensions[] = {N, len_m, len_n, len_p};
    npy_intp rdimensions[] = {dimensions[0], dimensions[3], dimensions[1], dimensions[2]};
    // steps = {strides_y, strides_x, strides_z,
    //     strides_y_r, strides_y_c,
    //     strides_x_r, strides_x_c,
    //     strides_z_r, strides_z_c, };
    // rsteps = {strides_x, strides_y, strides_z,
    //     strides_x_r, strides_x_c,
    //     strides_y_r, strides_y_c,
    //     strides_z_r, strides_z_c, };
    npy_intp rsteps[] = {steps[1], steps[0], steps[2],
        steps[5], steps[6],
        steps[3], steps[4],
        steps[7], steps[8]};
    //now that we've swapped a,b and transposed, proceed as if we're in matmul
    CFLOAT_matmul(rargs, rdimensions, rsteps, NULL);
}


#line 141

// matmul_signature = "(m,n),(n,p)->(m,p)";

static void
CDOUBLE_matmul(char **args, npy_intp *dimensions, npy_intp *steps,
              void *NPY_UNUSED(func))
{
INIT_OUTER_LOOP_3

    npy_intp len_m = *dimensions++;  // dimensions of left
    npy_intp len_n = *dimensions++;  // dimensions of inner
    npy_intp len_p = *dimensions++;  // dimensions of right
    npy_intp stride_x_m = *steps++;  // 1st arg
    npy_intp stride_x_n = *steps++;
    npy_intp stride_y_n = *steps++;  // 2nd arg
    npy_intp stride_y_p = *steps++;
    npy_intp stride_z_m = *steps++;  // output
    npy_intp stride_z_p = *steps++;
    npy_intp m, n, p;
    npy_intp iback_x_n = len_n * stride_x_n;  // step back at end of loop
    npy_intp iback_y_n = len_n * stride_y_n;
    npy_intp iback_y_p = len_p * stride_y_p;  // step back at end of loop
    npy_intp iback_z_p = len_p * stride_z_p;

    BEGIN_OUTER_LOOP

        const char *ip_x= args[0];  //  1st arg
        const char *ip_y= args[1];  //  2nd arg
        char *op_z = args[2];       //  output

        for (m = 0; m < len_m; m++) {
            for (p = 0; p < len_p; p++) {
                *(DOUBLECOMPLEX_t *)op_z = z_zero;

                for (n = 0; n < len_n; n++) {
#if 1
                        CDOUBLE_add_product_scalar((DOUBLECOMPLEX_t *)ip_x, (DOUBLECOMPLEX_t *)ip_y, (DOUBLECOMPLEX_t *)op_z);
#else
                        *(DOUBLECOMPLEX_t *)op_z += *(DOUBLECOMPLEX_t *)ip_x * *(DOUBLECOMPLEX_t *)ip_y;
#endif


                    ip_x += stride_x_n;
                    ip_y += stride_y_n;
                }
                ip_x -= iback_x_n;
                ip_y -= iback_y_n;

                ip_y += stride_y_p;
                op_z += stride_z_p;
            }
            ip_y -= iback_y_p;
            op_z -= iback_z_p;

            ip_x += stride_x_m;
            op_z += stride_z_m;
        }

    END_OUTER_LOOP_3
}

/********************************
*           RMATMUL             *
*********************************/

// rmatmul_signature = "(n,p),(m,n)->(m,p)";

static void
CDOUBLE_rmatmul(char **args, npy_intp *dimensions, npy_intp *steps,
              void *NPY_UNUSED(func))
{
    /*swap (X,Y) for (Y,X)
    x,y here are not the same as X,Y  in docstring: x=Y, y=X */
    char *rargs[] = {args[1], args[0], args[2]};
    // dimensions = {N, len_n, len_p, len_m};
    // rdimensions[] = {N, len_m, len_n, len_p};
    npy_intp rdimensions[] = {dimensions[0], dimensions[3], dimensions[1], dimensions[2]};
    // steps = {strides_y, strides_x, strides_z,
    //     strides_y_r, strides_y_c,
    //     strides_x_r, strides_x_c,
    //     strides_z_r, strides_z_c, };
    // rsteps = {strides_x, strides_y, strides_z,
    //     strides_x_r, strides_x_c,
    //     strides_y_r, strides_y_c,
    //     strides_z_r, strides_z_c, };
    npy_intp rsteps[] = {steps[1], steps[0], steps[2],
        steps[5], steps[6],
        steps[3], steps[4],
        steps[7], steps[8]};
    //now that we've swapped a,b and transposed, proceed as if we're in matmul
    CDOUBLE_matmul(rargs, rdimensions, rsteps, NULL);
}



/**********************************
*            NORM                 *
***********************************/

#line 245
static void
CFLOAT_add_abs_sq(const COMPLEX_t *x_in, npy_float *r_out)
{
    *r_out += x_in->array[0] * x_in->array[0] + x_in->array[1] * x_in->array[1];
}

#line 245
static void
CDOUBLE_add_abs_sq(const DOUBLECOMPLEX_t *x_in, npy_double *r_out)
{
    *r_out += x_in->array[0] * x_in->array[0] + x_in->array[1] * x_in->array[1];
}


#line 260

// norm_signature = "(n)->()";

static void
FLOAT_norm(char **args, npy_intp *dimensions, npy_intp *steps,
              void *NPY_UNUSED(func))
{
INIT_OUTER_LOOP_2

    npy_intp len_n = *dimensions++;  // dimensions of inner
    npy_intp stride_n = *steps++;
    npy_intp n;
    npy_float normsq;

    BEGIN_OUTER_LOOP

        const char *ip_x= args[0];  //  1st arg
        char *op_r = args[1];       //  output
        normsq = s_zero;

        for (n = 0; n < len_n; n++) {
#if 0
                FLOAT_add_abs_sq((npy_float *)ip_x, &normsq);
#else
                normsq += *(npy_float *)ip_x * *(npy_float *)ip_x;
#endif

            ip_x += stride_n;
        }
        *(npy_float *)op_r = npy_sqrtf(normsq);

    END_OUTER_LOOP_2
}


#line 260

// norm_signature = "(n)->()";

static void
DOUBLE_norm(char **args, npy_intp *dimensions, npy_intp *steps,
              void *NPY_UNUSED(func))
{
INIT_OUTER_LOOP_2

    npy_intp len_n = *dimensions++;  // dimensions of inner
    npy_intp stride_n = *steps++;
    npy_intp n;
    npy_double normsq;

    BEGIN_OUTER_LOOP

        const char *ip_x= args[0];  //  1st arg
        char *op_r = args[1];       //  output
        normsq = d_zero;

        for (n = 0; n < len_n; n++) {
#if 0
                DOUBLE_add_abs_sq((npy_double *)ip_x, &normsq);
#else
                normsq += *(npy_double *)ip_x * *(npy_double *)ip_x;
#endif

            ip_x += stride_n;
        }
        *(npy_double *)op_r = npy_sqrt(normsq);

    END_OUTER_LOOP_2
}


#line 260

// norm_signature = "(n)->()";

static void
CFLOAT_norm(char **args, npy_intp *dimensions, npy_intp *steps,
              void *NPY_UNUSED(func))
{
INIT_OUTER_LOOP_2

    npy_intp len_n = *dimensions++;  // dimensions of inner
    npy_intp stride_n = *steps++;
    npy_intp n;
    npy_float normsq;

    BEGIN_OUTER_LOOP

        const char *ip_x= args[0];  //  1st arg
        char *op_r = args[1];       //  output
        normsq = s_zero;

        for (n = 0; n < len_n; n++) {
#if 1
                CFLOAT_add_abs_sq((COMPLEX_t *)ip_x, &normsq);
#else
                normsq += *(COMPLEX_t *)ip_x * *(COMPLEX_t *)ip_x;
#endif

            ip_x += stride_n;
        }
        *(npy_float *)op_r = npy_sqrtf(normsq);

    END_OUTER_LOOP_2
}


#line 260

// norm_signature = "(n)->()";

static void
CDOUBLE_norm(char **args, npy_intp *dimensions, npy_intp *steps,
              void *NPY_UNUSED(func))
{
INIT_OUTER_LOOP_2

    npy_intp len_n = *dimensions++;  // dimensions of inner
    npy_intp stride_n = *steps++;
    npy_intp n;
    npy_double normsq;

    BEGIN_OUTER_LOOP

        const char *ip_x= args[0];  //  1st arg
        char *op_r = args[1];       //  output
        normsq = d_zero;

        for (n = 0; n < len_n; n++) {
#if 1
                CDOUBLE_add_abs_sq((DOUBLECOMPLEX_t *)ip_x, &normsq);
#else
                normsq += *(DOUBLECOMPLEX_t *)ip_x * *(DOUBLECOMPLEX_t *)ip_x;
#endif

            ip_x += stride_n;
        }
        *(npy_double *)op_r = npy_sqrt(normsq);

    END_OUTER_LOOP_2
}


/**************************************************************************
*                               RTRUEDIVIDE                               *
***************************************************************************/

#line 304
static void
CFLOAT_div(const COMPLEX_t *x_in, const COMPLEX_t *y_in, COMPLEX_t *r_out)
{
    npy_float abs_y = y_in->array[0] * y_in->array[0] + y_in->array[1] * y_in->array[1];
    r_out->array[0] = x_in->array[0] * y_in->array[0];
    r_out->array[0] += x_in->array[1] * y_in->array[1];
    r_out->array[0] /= abs_y;
    r_out->array[1] = x_in->array[1] * y_in->array[0];
    r_out->array[1] -= x_in->array[0] * y_in->array[1];
    r_out->array[1] /= abs_y;
}

#line 304
static void
CDOUBLE_div(const DOUBLECOMPLEX_t *x_in, const DOUBLECOMPLEX_t *y_in, DOUBLECOMPLEX_t *r_out)
{
    npy_double abs_y = y_in->array[0] * y_in->array[0] + y_in->array[1] * y_in->array[1];
    r_out->array[0] = x_in->array[0] * y_in->array[0];
    r_out->array[0] += x_in->array[1] * y_in->array[1];
    r_out->array[0] /= abs_y;
    r_out->array[1] = x_in->array[1] * y_in->array[0];
    r_out->array[1] -= x_in->array[0] * y_in->array[1];
    r_out->array[1] /= abs_y;
}


#line 322

static void
FLOAT_rtrue_divide(char **args, npy_intp *dimensions, npy_intp *steps,
              void *NPY_UNUSED(func))
{
    INIT_OUTER_LOOP_3
    BEGIN_OUTER_LOOP
#if 0
            FLOAT_div((npy_float *)args[1], (npy_float *)args[0], (npy_float *)args[2]);
#else
            *(npy_float *)args[2] = *(npy_float *)args[1] / *(npy_float *)args[0];
#endif
    END_OUTER_LOOP_3
}


#line 322

static void
DOUBLE_rtrue_divide(char **args, npy_intp *dimensions, npy_intp *steps,
              void *NPY_UNUSED(func))
{
    INIT_OUTER_LOOP_3
    BEGIN_OUTER_LOOP
#if 0
            DOUBLE_div((npy_double *)args[1], (npy_double *)args[0], (npy_double *)args[2]);
#else
            *(npy_double *)args[2] = *(npy_double *)args[1] / *(npy_double *)args[0];
#endif
    END_OUTER_LOOP_3
}


#line 322

static void
CFLOAT_rtrue_divide(char **args, npy_intp *dimensions, npy_intp *steps,
              void *NPY_UNUSED(func))
{
    INIT_OUTER_LOOP_3
    BEGIN_OUTER_LOOP
#if 1
            CFLOAT_div((COMPLEX_t *)args[1], (COMPLEX_t *)args[0], (COMPLEX_t *)args[2]);
#else
            *(COMPLEX_t *)args[2] = *(COMPLEX_t *)args[1] / *(COMPLEX_t *)args[0];
#endif
    END_OUTER_LOOP_3
}


#line 322

static void
CDOUBLE_rtrue_divide(char **args, npy_intp *dimensions, npy_intp *steps,
              void *NPY_UNUSED(func))
{
    INIT_OUTER_LOOP_3
    BEGIN_OUTER_LOOP
#if 1
            CDOUBLE_div((DOUBLECOMPLEX_t *)args[1], (DOUBLECOMPLEX_t *)args[0], (DOUBLECOMPLEX_t *)args[2]);
#else
            *(DOUBLECOMPLEX_t *)args[2] = *(DOUBLECOMPLEX_t *)args[1] / *(DOUBLECOMPLEX_t *)args[0];
#endif
    END_OUTER_LOOP_3
}



/*
*****************************************************************************
**                             Ufunc definition                            **
*****************************************************************************
*/

static char ufn_types_norm[] = { NPY_FLOAT, NPY_FLOAT,
                                NPY_DOUBLE, NPY_DOUBLE,
                                NPY_CFLOAT, NPY_FLOAT,
                                NPY_CDOUBLE, NPY_DOUBLE };

GUFUNC_FUNC_ARRAY_REAL_COMPLEX_INT(matmul);
GUFUNC_FUNC_ARRAY_REAL_COMPLEX_INT(rmatmul);
GUFUNC_FUNC_ARRAY_REAL_COMPLEX(norm);
GUFUNC_FUNC_ARRAY_REAL_COMPLEX(rtrue_divide);

GUFUNC_DESCRIPTOR_t gufunc_descriptors[] = {
    { "matmul", "(m,n),(n,p)->(m,p)", matmul__doc__, 5, 2, 1,
      FUNC_ARRAY_NAME(matmul), ufn_types_5_3 },
    { "rmatmul", "(n,p),(m,n)->(m,p)", rmatmul__doc__, 5, 2, 1,
      FUNC_ARRAY_NAME(rmatmul), ufn_types_5_3 },
    { "norm", "(n)->()", norm__doc__, 4, 1, 1,
      FUNC_ARRAY_NAME(norm), ufn_types_norm },
    { "rtrue_divide", NULL, matmul__doc__, 4, 2, 1,
      FUNC_ARRAY_NAME(rtrue_divide), ufn_types_4_3 }
};

/*
*****************************************************************************
**               Module initialization stuff                               **
*****************************************************************************
*/

static PyMethodDef GUfuncs_Cloop_Methods[] = {
    {NULL, NULL, 0, NULL}        /* Sentinel */
};

static struct PyModuleDef moduledef = {
        PyModuleDef_HEAD_INIT,
        "_gufuncs_cloop",
        NULL,
        -1,
        GUfuncs_Cloop_Methods,
        NULL,
        NULL,
        NULL,
        NULL
};

PyObject *PyInit__gufuncs_cloop(void)
{
    PyObject *m;

    init_constants();
    m = PyModule_Create(&moduledef);
    if (m == NULL) {
        return NULL;
    }

    import_array();
    import_ufunc();

    /* Load the ufunc operators into the module's namespace */
    int failure = addUfuncs(m, gufunc_descriptors, 4, gufuncs_cloop_version_string);

    if (PyErr_Occurred() || failure) {
        PyErr_SetString(PyExc_RuntimeError,
                        "cannot load _gufuncs_cloop module.");
        return NULL;
    }

    return m;
}

